{"meta":{"title":"Lishuai's博客","subtitle":null,"description":"承载着太多希望，怎敢轻易辜负","author":"李帅","url":"http://yoursite.com"},"pages":[{"title":"关于博主","date":"2018-02-24T11:36:41.000Z","updated":"2018-02-24T12:46:34.022Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"博主是一个正在努力进步的小菜，欢迎大家一起来交流学习！"},{"title":"分类","date":"2018-02-24T11:38:30.000Z","updated":"2018-02-24T12:44:22.899Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-02-24T11:37:58.000Z","updated":"2018-02-24T12:45:30.238Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"每日五题05","slug":"每日五题05","date":"2018-03-06T00:52:42.000Z","updated":"2018-03-06T04:24:58.352Z","comments":true,"path":"2018/03/06/每日五题05/","link":"","permalink":"http://yoursite.com/2018/03/06/每日五题05/","excerpt":"问题1：new delete free malloc的关系先简单介绍一下他们。1.new和delete 在c++中使用new和delete动态的创建和释放数组和单个对象。动态创建对象时，只需指定其数据类型，而不必为该对象命名，new表达式返回指向该新创建对象的指针，我们可以通过指针来访问此对象。","text":"问题1：new delete free malloc的关系先简单介绍一下他们。1.new和delete 在c++中使用new和delete动态的创建和释放数组和单个对象。动态创建对象时，只需指定其数据类型，而不必为该对象命名，new表达式返回指向该新创建对象的指针，我们可以通过指针来访问此对象。并且动态创建的对象可以直接初始化： int *p=new int(100);*p=10; int *p=new string(10,&apos;9&apos;);p=&quot;999999999&quot; int *p=int;//未初始化 int *p=int();//初始化为0 int *p=string();//调用默认构造函数 new delete和new []和delete []成对出现！不能混合使用，尽管对于内置类型来说，混合使用不会出错，但是最好不要混合使用。 1.malloc free malloc 向系统申请分配指定size个字节的内存空间，返回类型是 void 类型。void 表示未确定类型的指针。C,C++规定，void* 类型可以强制转换为任何其它类型的指针。 free用来释放malloc在堆上申请的空间。注意：malloc以后要对指针进行转换，free以后要将其置空，还要判断malloc是否成功。 有人在网上说new是在 自由存储区申请的，我觉得这句话可以直接屏蔽，当做没看见！ 下面说说他们的区别:.malloc和new的区别1.new返回指定类型的指针，并且可以自动计算需要的大小，而malloc需要我们自己计算所需空间的大小，并且需要将返回的 void *类型进行指定类型的转换 2.malloc在分配内存的时候只能分配，而不具有初始化的功能，而new具有。 3.malloc和free是标准库函数，而new/delete是C++的运算符，支持重载。malloc和free不支持 4.对于c++自定义类型，new和delete分别会调用对象的构造和析构函数，而这一点malloc/free做不到。 5.对于内置类型而言两者没有太大的区别！ 这里附上一篇博客： http://blog.csdn.net/bat67/article/details/52022105 问题2：子类析构时候要调用父类的析构函数吗？需要：前提子类B继承父类A1.先调用父类的构造函数，然后调用子类的构造函数。准确的说是在子类的构造函数中调用父类的构造函数。先析构子类，再析构父类（B b） 2.用父类指针指向子类对象，如果父类的析构函数不是虚函数的话，则不会释放子类对象，因为不会产生多态，所以因为是父类指针就只调用父类的析构函数。http://blog.csdn.net/it_iverson/article/details/78531651 问题3：描述内存分配及他们的区别1）从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static变量。 2）在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集。 3）从堆上分配，亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由程序员决定，使用非常灵活，但问题也最多。 问题4：分别写出BOOL,int,float,指针类型的变量a与“零”的比较语句1.对于bool型来说和0比较完全可以使用==0或者!=0,但是这种表达形式体现不出来true和false所以应该使用if(a)和if(!a) 2.对于int类型来说就要使用==和!=if(a==0)和if(a!=0) 3.对于float类型来说，不能使用！=和==的符号。因为浮点数是有误差的，它只能规定在这个范围内，所以判断两个浮点数是否相等需要，需要判断他们是否在一个区间内。所以在这里我们定义属于 [-EPSINON,EPSINON] 内得浮点数就可以认为是0，EPSINON是float类型的，只不过使用了typedef而已。 const EXPRESSION EXP = 0.000001 if ( a &lt; EXP&amp;&amp; a &gt;-EXP) 4.对于指针类型if(a==NULL)或者if(a!=NULL) 问题5：数组和指针的区别数组就是数组，指针就是指针。两个数组名除了在sizeof的情况下，都表示数组下标为0的元素的地址！int arr[3];int p=arr;int arr[][3];int p=arr;int **p=arr;这种赋值严格来说是错的，类型不匹配，在C++编译器下是无法通过的。","categories":[{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/categories/面试题/"},{"name":"c/c++","slug":"面试题/c-c","permalink":"http://yoursite.com/categories/面试题/c-c/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/面试题/"}]},{"title":"每日五题04","slug":"每日五题04","date":"2018-03-04T00:59:53.000Z","updated":"2018-03-06T04:25:15.720Z","comments":true,"path":"2018/03/04/每日五题04/","link":"","permalink":"http://yoursite.com/2018/03/04/每日五题04/","excerpt":"问题1：指针和引用的区别1.引用在定义的时候必须被初始化，而指针不用必须被初始化 2.引用初始化以后不能改变其引用对象，指针可以改变 3.不存在指向空值的引用，但是存在指向空值的指针","text":"问题1：指针和引用的区别1.引用在定义的时候必须被初始化，而指针不用必须被初始化 2.引用初始化以后不能改变其引用对象，指针可以改变 3.不存在指向空值的引用，但是存在指向空值的指针4.sizeof引用得到的是所指对象的大小，sizeof指针得到的是指针变量的大小和其指向的内容没有关系 5.指针和引用的自增运算意义不一样 6.引用的创建和销毁不会调用构造和析构函数 7.指针可以有多级，而引用只有一级 8.引用实质也是指针，const int *p=&amp;a，只不过这个工作是编译器帮我们做的 下面附上我关于引用的博客：http://blog.csdn.net/it_iverson/article/details/76832741 问题2：for(;1;)有什么问题？这是一个死循环，for中两个分好中间为判断条件，为真则执行。这里为1，相当于true，也就是死循环。等价于for(;;)也等价于while(1)。 那么下面来说说for(;;)和while(1)的区别 1、 for（；；）死循环里的两个；；代表两个空语句，编译器一般会优化掉它们，直接进入循环体。while（1）死循环里的1被看成表达式，每循环一次都要判断常量1是不是等于零。即，相对来说for式死循环更加高效一点当然以上条件成立还要看编译器的优化，一些编译器优化的两者并无区别，但是，并非所有的编译器都做了这样的优化。 2、for（；；）只有7个字符和while（1）相比省一个字符 问题3：用宏定义写swap(x,y)#define Swap(x,y) (x)=(x)+(y);(y)=(x)-(y);(x)=(x)-(y) #define Swap(x,y) (x)=((x)^(y));(y)=((x)^(y));(x)=((x)^(y)) 问题4：关键字const 和volatilehttp://blog.csdn.net/it_iverson/article/details/78488249这篇博客是关于const的详解下面说说volatile volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。声明时语法：int volatile vInt; 当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存 当一个 变量被const和volatile同时修饰的时候： 主要要搞清楚 编译期 和 运行期的关系。编译期就是 C 编译器将 源代码转化为 汇编再到机器代码 的过程。运行期就是 实际的机器代码在CPU执行 的过程。很多书上说的东西，其实都只是指编译期进行的事情。const 和 volatile 也一样，所谓的 const ，只是告诉编译器要保证在 C的“源代码”里面，没有对该变量进行修改的地方，就是该变量不能而出现在赋值符号左边。实际运行的时候则不是 编译器 所能管的了。同样，volatile的所谓“可能被修改”，是指“在运行期间”可能被修改。也就是告诉编译器，这个变量不是“只”会被这些 C的“源代码”所操纵，其它地方也有操纵它们的地方。所以，C编译器就不能随便对它进行优化了 。所以每次读它要在它内存中读，不要在寄存器中读备份。 问题5：struct和class的区别首先c++中对于struct进行了极大的改进和优化。下面我们来讲讲其和class的区别1.首先是对于默认访问权限的 区别。class如果不写的话就是私有，而struct是public的，c++中的struct也可以继承，实现多态，包含成员函数。所以class和struct可以混合继承，但是这里的继承权限取决于子类是struct还是class ,如果子类是 class 并且没有写继承权限的话就是私有继承，如果是struct并且没有写继承权限的话就是私有继承。 2.class可以用于定义模板参数，而struct不行 3.struct可以默认使用{}初始化，而class不行，因为其默认访问权限是private的,所以将其默认权限改成public的话class也可以使用{}。但是如果给struct加入构造函数，则struct也不能使用{}初始化了。","categories":[{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/categories/面试题/"},{"name":"c/c++","slug":"面试题/c-c","permalink":"http://yoursite.com/categories/面试题/c-c/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/面试题/"}]},{"title":"每日五题03","slug":"每日五题03","date":"2018-03-02T02:37:28.000Z","updated":"2018-03-03T02:50:43.706Z","comments":true,"path":"2018/03/02/每日五题03/","link":"","permalink":"http://yoursite.com/2018/03/02/每日五题03/","excerpt":"问题1：c++中为什么有时候要用extern “C”extern “C’的作用是：告诉C++编译器，我用extern “C”声明的函数，你给我当成C语言中的函数来处理，别走你的c++路线就可以了。为什么要这样呢？举个例子","text":"问题1：c++中为什么有时候要用extern “C”extern “C’的作用是：告诉C++编译器，我用extern “C”声明的函数，你给我当成C语言中的函数来处理，别走你的c++路线就可以了。为什么要这样呢？举个例子a.c文件内容如下： #include&lt;stdio.h&gt; int fun() { return 10; } b.cpp文件内容如下: #include&lt;iostream&gt; using namesapce std; extern int fun();//声明fun函数是外部的 int main() { cout&lt;&lt;fun()&lt;&lt;endl; return 0; } 现在a.c文件的内容我照c编译器取去编译汇编生成二进制文件a.o(gcc -c a.c),下面我们来编译b.cpp文件 g++ b.cpp a.o 我们会发现编译器会报错：错误内容是fun函数未定义，这是为什么呢？明明已经用extern声明了fun函数了还会报错。这就牵扯到了c++和c编译器对于函数的处理c++因为其支持函数重载，所以c++编译器在对函数名处理的过程中需要结合其函数名，参数类型等生成一个独一无二的函数名，而c编译器就只是简单的处理了一下函数名就完了。所以在上面的问题主要是c++编译器将b.cpp中的fun函数可能处理成了_fun_int_（假设）这种类型，而a.c中的函数被c编译器处理成了_fun这种类型，所以在连接的过程中b.cpp在a.c文件中只能找到_fun这个类型函数，和自己文件中的_fun_int_函数无法匹配，所以调用失败，所以显示的未定义。这个时候extern “C”就闪亮登场了。用extern “C”在b.cpp中声明fun函数,像这样 1 extern &quot;C&quot; int fun(); 2 extern &quot;C&quot; { int fun();} 两种形式都可以。那么c++编译器在处理b.cpp的时候就会把fun（）函数按照c语言的命名规则来处理，处理成_fun，这样的话刚好在a.c中找到了_fun，就可以调用成功了！这就是extern “C”的作用！ 强调： 1.gcc -c a.c将a.c生成目标文件等着连接器连接呢会生成a.o g++ b.cpp a.o问题2：全局变量和局部变量的区别 有区别：全局变量保存在内存的全局存储区中，占用静态的存储单元；局部变量保存在栈中，只有在所在函数被调用时才动态地为变量分配存储单元。当一个c程序占用内存以下的几个部分 栈：由编译器进行管理，自动分配和释放，存放函数调用过程中的各种参数、局部变量、返回值以及函数返回地址。操作方式类似数据结构中的栈。 堆：用于程序动态申请分配和释放空间。C语言中的malloc和free，C++中的new和delete均是在堆中进行的。正常情况下，程序员申请的空间在使用结束后应该释放，若程序员没有释放空间，则程序结束时系统自动回收。注意：这里的“堆”并不是数据结构中的“堆”。 全局（静态）存储区:分为DATA段和BSS段。DATA段（全局初始化区）存放初始化的全局变量和静态变量；BSS段（全局未初始化区）存放未初始化的全局变量和静态变量。程序运行结束时自动释放。其中BBS段在程序执行之前会被系统自动清0，所以未初始化的全局变量和静态变量在程序执行之前已经为0。 常量区：存放常量字符串。程序结束后由系统释放。 代码段：存放程序的二进制代码。 问题3:堆栈溢出一般由什么原因造成的1.没有回收垃圾资源 2.递归层次太深 3.分配了超额的空间 问题4：什么函数不能声明为虚函数首先先解释一下什么是虚函数，以及他的作用！然后再回答主问题 1.普通的函数，即不在类中。 因为普通的函数只能被重载，不能被继承，也不能被重写，在编译期间就绑定的函数，所以不能声明为虚函数，没意义。如果你 这样做了 ，编译器会告诉你声明无效！ 2.构造函数 这个我上篇文章中就很详细的说明了这里就不多解释了 3.内联函数 inline函数在编译时被展开，用函数体去替换函数，而virtual是在运行期间才能动态绑定的，这也决定了inline函数不可能为虚函数。（inline函数体现的是一种编译机制，而virtual体现的是一种动态运行机制） 4.静态成员函数 静态成员函数是类的组成部分，但是不是任何对象的组成部分，所有对象共享一份，没有必要动态绑定，也不能被继承【效果能，但机理不能。静态成员函数就一份实体，在父类里；子类继承父类时也无需拷贝父类的静态函数，但子类可以使用父类的静态成员函数】，并且静态成员函数只能访问静态变量。所以不能为virtual。 5.友元函数 友员函数不是类的成员函数，C++不支持友员被继承，所以不能为virtual。 能是虚函数的条件： 1.是类的成员函数； 2.能被继承； 3.动态编译绑定，动态；迟联编译： 注意：空指针不能调用虚函数，因为虚指针在创建对象时创建，没有创建对象就没有虚指针，那么用空指针调用虚函数就会崩溃！！ 空指针可以调用成员函数，前提是该成员函数没有调用类的成员变量，因为指针只要拿到函数的入口地址就可以调用该函数，但是如果调用了成员变量，则因为找不到成员变量而崩溃！！！学习自:http://blog.csdn.net/gogokongyin/article/details/51121974 问题5：全局变量可不可以定义在可被多个.C文件包含的头文件中？为什么？可以！只能用static声明就行！因为用static声明的全局变量就会变成静态全局变量此时他的作用域仅限于定义它的源文件，其他源文件不可见所以不会引起命名冲突和重定义！不然的话全局变量可以在多个源文件中声明，但是只能在一个源文件中定义，不然的话就会引起变量重定义的错误！","categories":[{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/categories/面试题/"},{"name":"c/c++","slug":"面试题/c-c","permalink":"http://yoursite.com/categories/面试题/c-c/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/面试题/"}]},{"title":"每日五题02","slug":"每日五题","date":"2018-03-01T01:20:34.000Z","updated":"2018-03-01T05:07:15.808Z","comments":true,"path":"2018/03/01/每日五题/","link":"","permalink":"http://yoursite.com/2018/03/01/每日五题/","excerpt":"问题1：构造函数能不能是虚函数？为什么？答：构造函数不能是虚函数。解释如下： 1.存储角度：虚函数对应一个虚表，而这个虚表又对应了一个vptr指针，这个指针是在对象的存储空间中的，但是调用虚函数需要用vptr找到虚表中的虚函数来调用，所以对象还没有构造呢 ？构造函数怎么能是虚函数呢？这是矛盾的一点。","text":"问题1：构造函数能不能是虚函数？为什么？答：构造函数不能是虚函数。解释如下： 1.存储角度：虚函数对应一个虚表，而这个虚表又对应了一个vptr指针，这个指针是在对象的存储空间中的，但是调用虚函数需要用vptr找到虚表中的虚函数来调用，所以对象还没有构造呢 ？构造函数怎么能是虚函数呢？这是矛盾的一点。 2.使用角度：虚函数的作用在于通过父类的指针或者引用来调用它的时候能够变成调用子类的那个成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。 3.从实现上看：构造一个对象的时候，必须知道对象的实际类型，而虚函数行为是在运行期间确定实际类型的。而在构造一个对象时，由于对象还未构造成功。编译器无法知道对象 的实际类型，是该类本身，还是该类的一个派生类，或是更深层次的派生类。无法确定。。。 问题2：什么是大小端？如何判断机器的大小端？首先给出大小端的来源： 端模式出自Jonathan Swift书写的《格列佛游记》一书，这本书根据将鸡蛋敲开的方法不同将所有的人分为两类，从圆头开始将鸡蛋敲开的人被归为Big Endian，从尖头开始将鸡蛋敲开的人被归为Littile Endian。小人国的内战就源于吃鸡蛋时是究竟从大头（Big-Endian）敲开还是从小头（Little-Endian）敲开。 在计算机业Big Endian和Little Endian也几乎引起一场战争。在计算机业界，Endian表示数据在存储器中的存放顺序。 大端：高位存在低地址，低位存在高地址； 小端：高位存在高地址，低位存在低地址；（intel的x86，ARM普遍都是属于小端） 你只需要记住：大端：高低，低高。小端：低低高高。大小端在网络字节序中也需要注意这个后面再补充。举个例子：那么怎么判断自己的机器的大小端呢？首先强调一句：CPU对数据的读取是从低地址到高地址的 int is_endian() { union MyUnion { int a; char b; }un; un.a =100;//0x0001不知道放在高端还是低端了， return un.b;//如果返回1的话，证明我们机器是低字节，低地址，即为小端 }//等于1证明为小端，等于0证明为大端 这里就列举一种方法当然还有其他方法，比如说强制类型转换，打印变量地址观察。 问题3：模拟实现strncpy,memcpy,memove1.简单描述strncpy:指定拷贝n个字节，n大于拷贝字节数则多余的补’\\0’,如果n&gt;存储空间，则正常崩溃，n小于拷贝字节，则自己在最后加一个’\\0’. char* my_strncpy(char *dest, char *src, size_t count) { assert(dest&amp;&amp;src); char *p = dest; while (count &amp;&amp; (*dest++ = *src++)) { count--; } if (count &gt; 0)//上述循环出来就意味着&apos;\\0&apos;都复制进去了 { while (--count) *dest++ = &apos;\\0&apos;; } return p; } 2.memcpy拷贝的时候容易覆盖，比图12345，我要把123拷贝到234的位置讲道理拷贝完以后应该是11235，但是用memcpy的话结果就是11115,因为当走到2的时候2已经被1覆盖了，则用1继续覆盖3…，所以我们就需要用memove来拷贝，它 可以实现逆向拷贝即从后往前拷贝,上述例子的拷贝就会是这个样子，把3给4，把2给3，把1给2，这样就不会出现覆盖的问题了即得到我们要的答案，11235 void* my_memcpy(void* dest, void* src, size_t count) { void* ret = dest; char *str1 = (char *)dest; char *str2 = (char *)src; assert(str1&amp;&amp;str2); while (count--) { *str1++ = *str2++; } return ret; } void* my_memove(void* dest, void* src, size_t count) { void* ret = dest; char *str1 = (char *)dest; char *str2 = (char *)src; assert(str1&amp;&amp;str2); if (str1 &gt; str2)//目标位置大于起始位置//使用反向拷贝 { while (count--) { *(str1 + count) = *(str2 + count); } } else { while (count--) { *str1++ = *str2++; } } return ret; } 问题4：“dynamic_cast”和“static _ cast”的区别首先C++提供了两个在层次间转换的关键字那么就是他们两个 首先来说说dynamic_cast： 该运算符把expression转换为type-id类型，但没有运行时类型检查来保证转换的安全性。它主要有如下几种用法： ①用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换。 进行上行转换（把派生类的指针或引用转换成基类表示）是安全的； 进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的。 ②用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性也要开发人员来保证。 ③把空指针转换成目标类型的空指针。 ④把任何类型的表达式转换成void类型。 注意：static_cast不能转换掉expression的const、volatile、或者__unaligned属性。 http://blog.csdn.net/qq_26849233/article/details/62218385 问题5： C++数据类型所表示的值及范围http://blog.csdn.net/a775992553/article/details/8790241","categories":[{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/categories/面试题/"},{"name":"c/c++","slug":"面试题/c-c","permalink":"http://yoursite.com/categories/面试题/c-c/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/面试题/"}]},{"title":"每日五题01","slug":"每日十题","date":"2018-02-28T02:39:09.000Z","updated":"2018-03-06T00:50:21.713Z","comments":true,"path":"2018/02/28/每日十题/","link":"","permalink":"http://yoursite.com/2018/02/28/每日十题/","excerpt":"问题1：写一个不能被继承的类，并且可以正常使用首先一个类不能被继承，则意味着继承这个类的类并没有办法正常工作，比如无法创建对象。所以根据我们对继承的了解，在构造子类对象时先调用基类的构造函数构造子类中基类的部分，所以我们可以在 这里讲父类的构造函数和析构函数设置为私有 ，这样的话，子类就无法正常的创建对象，也就实现了我们的题目所描述的问题了。代码如下：","text":"问题1：写一个不能被继承的类，并且可以正常使用首先一个类不能被继承，则意味着继承这个类的类并没有办法正常工作，比如无法创建对象。所以根据我们对继承的了解，在构造子类对象时先调用基类的构造函数构造子类中基类的部分，所以我们可以在 这里讲父类的构造函数和析构函数设置为私有 ，这样的话，子类就无法正常的创建对象，也就实现了我们的题目所描述的问题了。代码如下： class Base//基类 { private: Base() {}; ~Base(){}; }; Dervice :public Base//派生类 {}; 上面的这个例子中类Base就不能被继承。这样写虽然实现了问题的描述，不过也显得太挫了吧，因为虽然不能被继承，但是同时类Base也无法使用呀，因为其私有的构造函数和析构函数，我们没有办法在类外创建对象。这个时候你可能就会又有一个点子了，在类Base中使用static函数创建一个对象给外界使用不就好了嘛，因为static函数的调用不需要创建对象就可以调用，这样就可以在外界使用类Base了，这确实是个不错的注意。我们来看代码 class Base { private: Base() {}; ~Base(){}; public: static Base* getobj()//生产对象 { Base *p = new Base; return p; } static void delobj(Base *p)//再把对象送进来销毁 { delete p; p = NULL; } }; class Dervice :public Base {}; 这样的话，我们通过对static函数调用（Base s=Base::getobj()）从而实现对类Base的调用，并且如果需要参数的话还可以通过函数将参数传进去。但是这样的话貌似只能在堆上创建对象，而不能在栈上创建对象。可能有人会说你把new 改成 Base s,然后return s不就行了，呵呵。。你可别忘了，Base的析构函数也是私有的，所以在函数退出的地方没法调用私有函数。所以行不通。所以还是不够完美。那么我们接下来该如何优化呢？先给出代码 class Parent { private: ~Parent(){}; Parent(){}; friend class Base; }; class Base : virtual public Parent { public: Base(){}; ~Base(){}; }; class Dervice :public Base { public: Dervice(){}; ~Dervice(){}; }; 我们给通过这种形式就可以使Base可以正常的使用，并且他不能被继承。注意Base一定是虚继承Parent,因为只有根据虚继承的特性，当子类继承了Base以后，创建对象的时候直接去调用Parent的构造对象，从而无法成功。才使Base不能被继承。如果不使用虚继承的话，就会通Base的构造函数去调用，Parent的构造函数，这样是可以的，所以Base就能被继承了在这里需要注意一下！ 问题2：解释一下多态，并且一个多态的例子；说明一个类的默认函数有哪些。1.多态：通俗的说就是同样的调用语句有不同的表现形式。根据实际的对象类型从而决定调用语句的具体的调用目标。C++中对于多态的支持是通过virtual关键字，即使用virtual声明的函数被重写后可以实现多态性。多态只能发生在父类和子类之间。想实现多态有三个固定的条件缺一不可： ①：要有继承，即父类子类这种形式 ②要有虚函数的重写 ③需要父类的指针或者引用 说道多态其实又能牵扯到静态联编和动态联编 联编：就是指一个程序模块代码之间相互关联的一个过程 静态联编：静态联编是指联编工作在编译阶段完成的，这种联编过程是在程序运行之前完成的，又称为早期联编。要实现静态联编，在编译阶段就必须确定程序中的操作调用（如函数调用）与执行该操作代码间的关系，确定这种关系称为束定，在编译时的束定称为静态束定。静态联编对函数的选择是基于指向对象的指针或者引用的类型。其优点是效率高，但灵活性差。（比如重载函数使用静态联编） 动态联编：程序联编推迟到运行时刻进行，所以又成为晚期联编，迟邦定，比如switch和if语句。 不写virtual关键字，编译器实行的是静态联编，不管因为是父类类型所以不管参数类型是什么在编译阶段就确定执行父类的函数了，而动态联编就是在运行时根据不同对象决定调用哪个函数！ 至于多态的实现原理呢？ 1.当类中声明虚函数时，编译器会在类中生成一个虚函数表 2.虚函数表是一个存储类成员函数指针的数据结构 3.虚函数表是由编译器自动生成与维护的 4.virtual成员函数会被编译器放入虚函数表中 5.当存在虚函数时，每个对象中都有一个指向虚函数的指针（C++编译器给父类对象，子类对象提前布局vptr指针），当进行test(parent *base)函数的时候，C++编译器不需要区分子类或者父类对象，只需要再base指针中，找到vptr指针即可） 6.vptr一般作为类对象的第一个成员。 2.类的默认成员函数有：这个是我CSDN博客的详解http://blog.csdn.net/it_iverson/article/details/78511564 问题3：一个指针指向的内容经常变化，如何防止编译器去优化它答：这里考察的是volatitlehttp://blog.csdn.net/turkeyzhou/article/details/8953911 问题4：写一个字符串转浮点型在这个里考察的是atof的模拟实现首先对于算法中强调几点： 1.字符数字-‘\\0’=数字本身，举个例子‘1’的ascii的值为48,‘\\0’的ascii值为47,则48-47=1; 2.对于字符串需要判断是否有+-号 3.需要判断字符串是否有小数点 4.判断空格，是否属于0-9等等一些情况 double my_atof(char *ptr) { int count=0; double sum = 0.0; int flag = 0;//标志位判断是否有+-号,0负数，1正数 while (*ptr) { if (count) count *= 10; if (*ptr == &apos;+&apos;) { ptr++; flag = 1; } else if (*ptr == &apos;-&apos;) ptr++; else if (*ptr == &apos;.&apos;) { ptr++; count++; } else if (*ptr&gt;&apos;0&apos;&amp;&amp;*ptr&lt;&apos;9&apos;) { sum = sum*10 + (*ptr - &apos;0&apos;); ptr++; } else if (*ptr == &apos; &apos;) { ptr++; } else return 0; } sum = sum / count; if (flag == 0) return sum*(-1); else return sum; } 问题5：写一个strcpy函数char* my_strcpy(char *str, char *dest) { assert(str); assert(dest); char *src = str; while (*str++ = *dest++) ; return src; }","categories":[{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/categories/面试题/"},{"name":"c/c++","slug":"面试题/c-c","permalink":"http://yoursite.com/categories/面试题/c-c/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/面试题/"}]},{"title":"深度探索c++对象模型-第四章Function语意学","slug":"深度探索c++对象模型-第四章Function语意学","date":"2018-02-26T12:52:36.000Z","updated":"2018-02-26T14:40:33.735Z","comments":true,"path":"2018/02/26/深度探索c++对象模型-第四章Function语意学/","link":"","permalink":"http://yoursite.com/2018/02/26/深度探索c++对象模型-第四章Function语意学/","excerpt":"此篇文章主要的内容是向我们介绍C++中的一些函数的调用方式，比如成员函数，非常成员函数，静态成员函数，虚函数等等，其中每一种类型的函数的调用方式都不相同。并且除了说明此章节的主题意外还告诉我们了一个小知识点,那就是","text":"此篇文章主要的内容是向我们介绍C++中的一些函数的调用方式，比如成员函数，非常成员函数，静态成员函数，虚函数等等，其中每一种类型的函数的调用方式都不相同。并且除了说明此章节的主题意外还告诉我们了一个小知识点,那就是:①静态成员函数不可能直接存取非静态成员变量，因为它没有this指针，②静态成员函数不可能被声明为const，因为const修饰函数是防止他去修改成员变量的值，而静态成员函数根本不能访问成员，所以修饰它无任何意义，所以规定不能用const 修饰静态成员函数。 1.非静态成员函数作者告诉我们设计非静态成员函数的最起码这个函数需要和一般的非成员函数有同样的效率，假如有如下的两个函数 float magnitude3d(const Point3d *_this){..};//Point3d是类名 float Point3d::magnitude3d() const {..}; 我们看起来是不是成员函数相对来说没有 带来什么负担，反而效率似乎还能高一点，因为非成员函数中还需要经形参取值才能运用成员呢。其实吧，成员函数看着小清新，其实在真正使用的时候，成员函数也是被内化非成员函数的形式了，下面作者就介绍了这个内化的过程！ 1. 改写成员函数的原型，给其安插一个额外的参数到成员函数中，用来提供成员的操作，使得类对象可以将这个函数调用，而这个额外的参数就被称作this指针！代码如下： float Point3d::magnitude3d(Point3d *const this) const {..}; 如果说成员函数是const的，则会变为: float Point3d::magnitude3d(const Point3d *const this) const {..}; 2. 将对成员的存取操作变成这个样子 { this-&gt;_x*this-&gt;y; } 3.将成员函数重新写成一个外部函数（全局函数）。将函数名经过”mangling”处理，使他在程序中独一无二。（这里mangling就是给函数的变量和函数名字经过编译器自己的一些算法，重新起一个独一无二名字，这么做是为了支持C++重载）。致此，函数就内化完成了 extern magnitude_7Point3dFv(register Point3d* const this); 既然函数都被改的飞起来了，那么函数的调用毋庸置疑也被改掉了 Point obj; Point *ptr=&amp;obj; obj.magnitude();------&gt;magnitude_7Point3dFv(&amp;obj) ptr-&gt;magnitude();------&gt;magnitude_7Point3dFv(ptr) 2.虚函数对于虚函数的调用，如果是对象指针调用的话 Point *ptr=&amp;obj; ptr-&gt;normalize();//这个函数是虚函数的话 那么可能会是如下形式： (*(ptr-&gt;vptr[1]))(ptr); 这句话是调用虚函数。，ptr等同于this指针 3.静态成员函数首先先给出两个转换形式， obj.normalize();//静态成员函数调用 normalize_7Point3dSFv(); ptr-&gt;normalize(); normalize_7Point3dSFv(); 会将其转换成非成员函数的调用，即普通的调用。后面即介绍了一下静态成员函数的特点 1.没有this指针，所以不能访问成员变量 2.不能够被声明为volatitle,virtual,const. 3.不需要经过对象就可以调用。 因为其没有this指针的特性，所以其和非成员函数有点类似，所以对其取地址，得到的是非成员函数的指针而非成员函数的指针刑（int (Ponit3d::*)()).….然后此章节后面的内容就是介绍虚拟函数包括其一些对象模型。在这里就不多说了直接附上我的两篇模型剖析的博客，感兴趣的 自己去看看CSDN:http://blog.csdn.net/it_iverson/article/details/78206211自己的博客：http://lishuaii.top/2018/02/26/c++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%89%96%E6%9E%90/#more 后面我在抓抓本章的重点内容写一写吧！嗯…… 然后没发现什么哈哈！！这里在附上一篇inline的详解的博客咯：http://blog.csdn.net/it_iverson/article/details/78473778","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/categories/读书笔记/"},{"name":"深度探索C++对象模型","slug":"读书笔记/深度探索C-对象模型","permalink":"http://yoursite.com/categories/读书笔记/深度探索C-对象模型/"}],"tags":[{"name":"function语意学","slug":"function语意学","permalink":"http://yoursite.com/tags/function语意学/"}]},{"title":"C++对象模型的剖析","slug":"c++对象模型的剖析","date":"2018-02-26T07:11:42.000Z","updated":"2018-02-26T10:08:22.289Z","comments":true,"path":"2018/02/26/c++对象模型的剖析/","link":"","permalink":"http://yoursite.com/2018/02/26/c++对象模型的剖析/","excerpt":"1.单继承对象模型（含有虚函数）首先阐述对象模型：","text":"1.单继承对象模型（含有虚函数）首先阐述对象模型：1.子类和父类都拥有各自的虚函数表 2.如果子类重写了父类的虚函数，则在子类的虚函数表中替换同名的父类虚函数，如果没有重写，则子类的虚函数表中是父类的虚函数（注意在这里只要子类的函数 中有和父类一样的，不管子类加不加vartual，都是重写父类的虚函数） 3.如果子类有自己新写的虚函数，则该虚函数放在虚函数表的后面 class Base { public: int a; public: virtual void fun1() { cout &lt;&lt; &quot;base::fun1()&quot; &lt;&lt; endl; } virtual void fun2() { cout &lt;&lt; &quot;base::fun2()&quot; &lt;&lt; endl; } }; class Dervice :public Base { public: int b; public: virtual void fun2() { cout &lt;&lt; &quot;Dervice::fun2()&quot; &lt;&lt; endl; } virtual void fun3() { cout &lt;&lt; &quot;Dervice::fun3()&quot; &lt;&lt; endl; } }; void test() { Base b; Dervice d; Base *p = &amp;d; b.a = 10; d.b = 20; d.a = 30; } 首先来看base类的对象模型：然后看d的对象模型下面来验证一下 ： typedef void(*fun)(); fun *pp = (fun*)(*(int*)&amp;d); (*pp)(); pp++; (*pp)(); pp++; (*pp)(); 2.简单多继承对象模型简单描述： 1.如果子类新增虚函数，则放在声明的第一个父类的虚函数表中（理解成继承下来的虚表比较好理解）， 2.如果子类重写了父类的虚函数（两个父类中都有的那个虚函数），所有父类虚函数表都要改变。 3.子类内存布局中父类按照其声明顺序排列 class Base1 { public: int base1; public: virtual void fun1() { cout &lt;&lt; &quot;base1::fun1()&quot; &lt;&lt; endl; } }; class Base2 { public: int base2; public: virtual void fun1() { cout &lt;&lt; &quot;base2::fun1()&quot; &lt;&lt; endl; } virtual void fun2() { cout &lt;&lt; &quot;base2::fun2()&quot; &lt;&lt; endl; } }; class Dervice :public Base1,public Base2 { public: int b; public: virtual void fun1() { cout &lt;&lt; &quot;Dervice::fun1()&quot; &lt;&lt; endl; } virtual void fun3() { cout &lt;&lt; &quot;Dervice::fun3()&quot; &lt;&lt; endl; } }; void test() { Base1 b1; Base2 b2; Dervice d; b1.base1 = 10; b2.base2 = 20; d.b = 30; d.base1 = 40; d.base2 = 50; } 验证输出： typedef void(*fun)(); fun *pp = (fun*)(*(int*)&amp;d); (*pp)(); pp++; (*pp)(); pp += 2; /*pp++;*/ (*pp)(); pp++; (*pp)(); 3.简单虚继承对象模型简单阐述： 1.虚继承的子类，如果本身定义了新的虚函数，则编译器为其生成一个新的vptr指针和和虚表，将其新定义的虚函数放进去，并且这个vptr位于对象的最前面 2.虚继承的子类也保留了父类的vptr和虚表 3.虚继承的子类有虚基类表指针vbptr，虚基类表中放的第一个是基类表指针到到对象首地址的偏移地址，后面的则放的是到第二个，第三个虚继承父类的偏移值。 class Base1 { public: int base1; public: virtual void fun1() { cout &lt;&lt; &quot;base1::fun1()&quot; &lt;&lt; endl; } virtual void fun2() { cout &lt;&lt; &quot;base1::fun2()&quot; &lt;&lt; endl; } }; class Dervice :virtual public Base1 { public: int b; public: virtual void fun1() { cout &lt;&lt; &quot;Dervice::fun1()&quot; &lt;&lt; endl; } virtual void fun3() { cout &lt;&lt; &quot;Dervice::fun3()&quot; &lt;&lt; endl; } }; void test() { Base1 b1; Dervice d; b1.base1 = 10; d.b = 20; d.base1 = 30; } 4.菱形继承对象模型菱形继承是多继承和虚继承的复合 class A { public: int _a; virtual void fun1() { cout &lt;&lt; “A::fun1” &lt;&lt; endl; } virtual void fun2() { cout &lt;&lt; “A::fun2” &lt;&lt; endl; } }; class B1 : virtual public A { public: int _b1; virtual void fun1() { cout &lt;&lt; “B1::fun1” &lt;&lt; endl; } virtual void fun3() { cout &lt;&lt; “B1::fun3” &lt;&lt; endl; } }; class B2 :virtual public A { public: int _b2; virtual void fun1() { cout &lt;&lt; &quot;B2::fun1&quot; &lt;&lt; endl; } virtual void fun4() { cout &lt;&lt; &quot;B2::fun4&quot; &lt;&lt; endl; } }; class C :public B1, public B2 { public: int _c; virtual void fun1() { cout &lt;&lt; &quot;C::fun1&quot; &lt;&lt; endl; } virtual void fun3() { cout &lt;&lt; &quot;C::fun3&quot; &lt;&lt; endl; } virtual void fun4() { cout &lt;&lt; &quot;C::fun4&quot; &lt;&lt; endl; } virtual void fun5() { cout &lt;&lt; &quot;C::fun5&quot; &lt;&lt; endl; } };void test() { cout &lt;&lt; &quot;A:&quot; &lt;&lt; sizeof(A) &lt;&lt; endl; cout &lt;&lt; &quot;B1:&quot; &lt;&lt; sizeof(B1) &lt;&lt; endl; cout &lt;&lt; &quot;B2:&quot; &lt;&lt; sizeof(B2) &lt;&lt; endl; cout &lt;&lt; &quot;C:&quot; &lt;&lt; sizeof(C) &lt;&lt; endl; A a; B1 b1; B2 b2; C c; a._a = 10; b1._a = 10; b1._b1 = 20; b2._b2 = 30; b2._a = 10; c._c = 40; c._a = 10; c._b1 = 20; c._b2 = 30; }","categories":[{"name":"c/c++","slug":"c-c","permalink":"http://yoursite.com/categories/c-c/"}],"tags":[{"name":"对象模型剖析","slug":"对象模型剖析","permalink":"http://yoursite.com/tags/对象模型剖析/"}]},{"title":"c陷阱与缺陷","slug":"c陷阱与缺陷","date":"2018-02-25T15:10:39.000Z","updated":"2018-02-26T06:53:49.448Z","comments":true,"path":"2018/02/25/c陷阱与缺陷/","link":"","permalink":"http://yoursite.com/2018/02/25/c陷阱与缺陷/","excerpt":"1.词法陷阱1.注意不要讲=和==混用，还有&amp;和&amp;&amp;是两回事，这个自己都要搞清楚。","text":"1.词法陷阱1.注意不要讲=和==混用，还有&amp;和&amp;&amp;是两回事，这个自己都要搞清楚。 2.词法分析使用的是贪心法，即读取一个字符以后，如果该字符可能组成一个符号，则继续读入下一个 字符，然后判断两个字符组成的字符串是否可以是一个符号的组成部分，如果是则继续读入依此类推。 3.用单引号引起来的一个字符实际上表示一个整数，整数值对应其ascii的值。而双引号引起来的字符串表示的是一个指向无名数组起始字符的指针，该数组被双引号引起来的字符和一个额外的’\\0’初始化 4.用int a=’abc’,则a的值是616263即每个字符对应的ascii的序列，用char a=’abc’，则a的值是c。即c将ab覆盖 5.a+++++b的解释，词法分析的贪心算法可以解得为a ++ ++ + b即((a++)++)+b,但是a++不能当左值，所以这应该是个错误的写法。 2.语法陷阱1. (*(void(*)())0)() 将0转换为函数指针（这个函数指针返回值为void参数为空），然后再调用这个函数.用typedef比较好理解 typedef void (*funcptr)(); (*(funcptr)0)(); 2. (void)(*signal(int,void(*)(int)))(int); signal的参数是整形和函数指针,返回值也是函数指针。用typedef比较好理解 typedef (void ) (*handler)(int); handler signal(int,handler); 3.else总是和同一对括号内最近的未匹配的if相结合。 3.语义陷阱1.如果我们在该使用指针的，确使用了数组名来替换，那么数组名就被当做指向该数组下标为0的元素的指针，所以我们可以这样写 int arr[]={1,2,3}; int *p=arr;//没有任何问题 注意在上述代码中我们并没有写成如下形式 int *p=&amp;arr; 其实这是不合法的操作，因为其类型不匹配，&amp;arr表示整个数组的指针其类型是int[3]*,所以如果你这么写了可能会被视为非法也可能被视为和p=arr一样的操作。 要强调的是：数组名除了在sizeof中以外，其余的所有情形都表示数组下标为0的元素的指针。 （上述问题的背景还限于一维数组，下面我们来讨论一下二维数组） 二维数组其实也是由一维数组组成的，只不过这个一维数组中的每个元素都是一个一维数组。所以如果你这么赋值是不对的 int arr[][3]={1,2,3,4,5,6,7,8,9} int *p=a;错 int **p=a;错 因为a表示数组下标为0的元素的指针，因为其实二维数组，其下标为0的元素也是个数组，所以a的类型就是int (*)[3],类型不兼容的！如果你这么使用了，虽然可能会通过编译，那么将失去了二维数组的意义，就是将二维数组变成了一维数组。我们正确的方式应该是这样的 int (*p)[3]=a; 2.对于指针的复制并不是复制指针的内容，而是使两个指针指向同一块区域，还有就是对字符串常量的修改是非法的！不能对空指针解引用！即使输出空指针的内容也是不合法的！ 3.关于数组越界的无限循环问题 int i, arr[10] = {0}; for (i = 0; i &lt;= 12; i++) { arr[i] = 0; printf(&quot;hello\\n&quot;); } 此代码会无限输出hello,原因如下 4.连接1.连接器：就是想编译汇编产生的若干目标模块，整和成一个被称为载入模块或者可执行程序文件的实体，该实体可以被操作系统直接执行。并且会检查是否有重命名的函数和变量。 2.为了避免发生不必要的麻烦，每个外部变量在所有源文件中只能定义一次。 3.使用static可以防止不同源文件的命名冲突问题，因为它限制了变量的作用域。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/categories/读书笔记/"}],"tags":[{"name":"c陷阱与缺陷","slug":"c陷阱与缺陷","permalink":"http://yoursite.com/tags/c陷阱与缺陷/"}]},{"title":"链表随笔","slug":"链表随笔","date":"2018-02-25T09:29:58.000Z","updated":"2018-02-25T14:18:19.269Z","comments":true,"path":"2018/02/25/链表随笔/","link":"","permalink":"http://yoursite.com/2018/02/25/链表随笔/","excerpt":"此篇文章的主要内容是介绍一些有关链表的核心算法的总结。","text":"此篇文章的主要内容是介绍一些有关链表的核心算法的总结。 1.查找链表倒数第k个结点算法：此算法需要使用快慢指针，举个例子，加入需要查找倒数第3个结点。则指针先走k-1步，然后快慢指针一起走，当快指针指向最后一个结点的 时候，这个时候慢指针则指向我们要查找的倒数第3个结点。代码如下 int K_data(int location)//查找倒数第k个结点 { if (location &gt; 0)//不能小于0 { assert(_head); PNode fast = _head; PNode slow = _head; while (--location) { fast = fast-&gt;_next;// if (fast == NULL) exit(1);//不能超过结点个数 } while (fast-&gt;_next != NULL) { fast = fast-&gt;_next; slow = slow-&gt;_next; } return slow-&gt;_data; } else { exit(0);//直接退出 } } 强调： 1.注意判断查找点是否小于0或大于结点个数，还有结点是否为空 2.使快指针先走k-1步的方法是使用while循环并且使用前置– 3.快慢指针同时走的结束标志是fast-&gt;next！=null，这样就保证了fast刚好走到最后一个结点，如果使用fast!=null的话，则fast就会多走一步，同样慢指针也会多走，算法就会出错！ 2.查找链表中间结点算法：此方法和查找倒数第k个结点的算法思想是一样的，也是使用快慢指针，只不过这个很简单，即快指针走两步，慢指针走一步，这样当快指针到最后一个结点的位置的时候，慢指针则指向中间的结点。 int Find_Middle()//查找中间元素 { PNode fast = _head; PNode slow = _head; while (fast&amp;&amp;fast-&gt;_next) { fast = fast-&gt;_next-&gt;_next; slow = slow-&gt;_next; } return slow-&gt;_data; } 强调： 1.需要对链表进行判空，上述代码没有进行这个操作 2.while循环中的fast和fast-_next的位置步能放反不然就会出错，因为当fast走了两步以后，可能已经为空了，如果你放反了的话，则用空指next，肯定会报错的！ 3.链表逆置算法：逆置链表就是改变结点中的next的指向嘛，所以我们需要定义三个指针，一个指向当前需要逆置的结点的前一个结点，一个指向当前需要逆置的结点，一个指向当前需要逆置结点的后一个结点，然后将当前结点的指针指向前一个结点，然后三个指针同时向前走一步。直到遍历完整个链表注意这里的判断依据是指向需要逆置的结点的这个指针为空的时候则整个链表逆置完成。 void rever()//逆置链表 { if (_head == NULL) return; PNode pre =NULL; PNode next = NULL; PNode cur = _head; while (cur) { next = cur-&gt;_next;//首先让next先走一步 cur-&gt;_next = pre;//改变当前结点的_next pre = cur;//前一个结点走到当前结点 cur = next;//当前结点向前走 } _head = pre; } 强调： 1.注意while循环的指针的指向 2.开始的时候前指针和后指针都是指向空的。 3.最后记得将头指针更新，即最后一个结点变为头指针！ 4.合并两个有序链表合并后的链表也是有序链表算法：选取连个链表中头结点较小的作为头指针，定义一个指向最新的结点的指针，然后作为头指针的链表向后走一步，然后开始判断两个链表谁的结点数小，将其小补在新补的结点后面，然后链表向后走依次比较，直到有一个链表遍历完为止，然后需要判断一下是哪个链表遍历完了，将未遍历完的链表续在其后面。 PNode MergeList(List&lt;T&gt;&amp; s2) { PNode cur1=(*this)._head; PNode cur2 = s2._head; PNode head=NULL; PNode p = NULL; if (cur1 == NULL || cur2 == NULL) return NULL; if (cur1 == cur2) return cur1; if (cur1 != NULL&amp;&amp;cur2 == NULL) return cur1; if (cur2 != NULL&amp;&amp;cur1 == NULL) return cur2; if (cur1-&gt;_data &gt; cur2-&gt;_data)//选较小的作为新链表的头节点 { head = cur2; cur2 = cur2-&gt;_next; } else { head = cur1; cur1 = cur1-&gt;_next; } p = head;//p永远指向最新的结点 while (cur1&amp;&amp;cur2)//如果跳出循环至少有一个为空 { if (cur1-&gt;_data &gt; cur2-&gt;_data)// { p-&gt;_next = cur2; cur2 = cur2-&gt;_next; } else { p-&gt;_next = cur1; cur1 = cur1-&gt;_next; } p = p-&gt;_next; } if (cur1 == NULL) { p-&gt;_next = cur2; } else { p-&gt;_next = cur1; } return head; } 强调： 1.要有指向最新的结点的指针 2.需要对两个链表进行判空操作 5.判断链表是否带坏算法：这个也是需要两个指针，让快指针一次走两步慢指针一次走一步，然后判断快指针是否等于慢指针，等于的话直接返回，证明其带环，因为如果链表带环的话，他们一定会在环上相遇的，如果当fast等于null的时候则说明不带环 PNode JudgeisCircle()//判断链表是否带环 { PNode fast = _head; PNode slow = _head; while (fast&amp;&amp;fast-&gt;_next) { fast = fast-&gt;_next-&gt;_next; slow = slow-&gt;_next; if (fast == slow) return fast;//返回相遇点 } return NULL; } 强调： 1.循环的结束条件是fast&amp;&amp;fast-&gt;_next不等于null，并且顺序不能放反，原理和查找中间结点的理由一样。这样做是为了避免一个结点的时候走两步产生的错误 2.这里返回的是连个结点的相遇点，这个很重要，在求入口点的时候能够用的到 6.求带环链表的交点，即环的入口点算法：这个算法需要用到一点数学思维，先说结果吧即从像雨点到入口点的距离等于从起点到入口点的距离，下面我画图说明吧。下面给出代码： PNode EntrancePoint() { PNode cur = JudgeisCircle();//相遇点 PNode start = _head; while (cur != start) { cur = cur-&gt;_next; start = start-&gt;_next; } return cur; } 强调： 1.一定要将如何推倒这个结论的过程屡清楚 2.循环里面的内容是cur!=start 未完待续….","categories":[{"name":"数据结构随笔","slug":"数据结构随笔","permalink":"http://yoursite.com/categories/数据结构随笔/"}],"tags":[{"name":"链表","slug":"链表","permalink":"http://yoursite.com/tags/链表/"}]},{"title":"static详解","slug":"static详详解","date":"2018-02-25T05:15:28.000Z","updated":"2018-02-25T08:14:11.678Z","comments":true,"path":"2018/02/25/static详详解/","link":"","permalink":"http://yoursite.com/2018/02/25/static详详解/","excerpt":"static关键字是c和c++中都有的，只不过在c语言中它修饰局部变量，全局变量，和函数,在C++中它除了上述的功能外还可以修饰成员变量和成员函数。","text":"static关键字是c和c++中都有的，只不过在c语言中它修饰局部变量，全局变量，和函数,在C++中它除了上述的功能外还可以修饰成员变量和成员函数。 作用： 1.限定作用域 2.保持变量的内容持久化 1.C语言中的static1.修饰全局变量当一个进程的全局变量被static修饰以后，它就可以成为全局静态变量，全局静态变量和其他的全局变量的存储地是一样的，都是在.data段（存放已经初始化了的全局变量）或者.bss段（存放未初始化的全局变量），具体在哪里取决于你有没有初始化这个全局变量。在这里static的作用就是限定作用域了，即被修饰的全局变量只能在定义它的源文件内有效，其他源文件无法访问。 举例如下： .h文件 #include&lt;stdio.h&gt; extern int a;//声明全局变量 void fun();//声明函数 b.c文件 b.c文件 #include&quot;head.h&quot; static int a = 10;//静态全局变量，放在了.data段 void fun() { printf(&quot;%d\\n&quot;, a); } a.c文件 #include&quot;head.h&quot; int main() { printf(&quot;%d&quot;, a); return 0; } 在上述例子中，a.c文件无法使用源文件b.c的被static修饰的全局变量，编译会报错！但是如果在a.c中调用fun函数，在这个函数中使用a就可以，因为其作用域就在其定义的源文件，所以被自己的源文件内的函数访问是没有问题的。 2.修饰局部变量被static修饰的局部变量会被放在.data段，注意这里不是在.bss段，所以这个变量的生命周期在整个程序的生命周期中存在，尽管被放在.data段，但是同样它也只能被自己作用域内的函数或者变量所访问，不能被外界访问。同样static在这里的作用相当于改变了局部变量的生命周期。注意这里解释一下为什么放在了.data段，因为如果用户没有初始化的话，编译器会自动给其赋值0，所以放在了.data段。所以以后每次调用这个变量的时候相当于一直读取同一位置的这个变量，在这里注意和局部变量区别开来。就是因为这一特性，内含静态局部变量的函数是不可重入函数。 b.c文件 #include&quot;head.h&quot; void fun() { static int a; printf(&quot;%d\\n&quot;, a++); } a.c文件 #include&quot;head.h&quot; int main() { fun(); fun(); fun(); getchar(); return 0; } 这样的输出结果是0 1 2. 3.修饰函数这里static的作用也是限定了函数的作用，使被static修饰的函数不能被其他源文件所调用。这里很简单的就不举例子了。static函数可以很好的解决不同源文件中的函数重名的问题，因为每个函数的名字仅自己可见，肯定不会发生冲突的！ 2.C++中的staticC++的中的static关键字主要要讲的就是其修饰的成员变量和成员函数。 1.static修饰成员变量当一个类的成员变量被static关键字修饰以后就变成了静态数据成员了，静态数据成员有一下特点： 1.静态数据成员是类的成员而非对象的成员，它对于所有的对象是共享的，即无论对象被定义了多少个这个静态的成员只有一份，即只分配一次内存，这一样某种程度来说还节省了空间 2.静态成员存储在全局数据区，静态成员在定义的时候要分配空间，所以不不能再类声明的时候定义，需要在类外使用如下形式定义 int myclass::a=0; 3.静态成员同样遵守三个访问限制，同时即使不定义类对象也可以对它进行操作 4.静态成员的作用就是在多个对象拥有同一个属性的时候，使用它可以方便操作，改变一次就全部改变，使用静态数据成员也不存在和其他全局变量的名字冲突，因为其有访问限制属性所以可以实现信息隐藏。 2.static修饰成员函数1.同样静态成员函数也是被所有对象共享，并且他没有this指针，所以他不能访问成员函数和成员变量只能访问静态成员函数和静态成员变量，但是非静态成员函数可以访问静态成员函数和静态变量 2.因为没有this指针，其速度相对于成员函数来说会快一些 3.调用静态成员函数的方式和调用静音胎成员的方式差不多，可以使用.，-&gt;和::","categories":[{"name":"c/c++","slug":"c-c","permalink":"http://yoursite.com/categories/c-c/"}],"tags":[{"name":"static","slug":"static","permalink":"http://yoursite.com/tags/static/"}]},{"title":"堆随笔","slug":"堆随笔","date":"2018-02-24T13:59:15.000Z","updated":"2018-02-24T15:00:39.218Z","comments":true,"path":"2018/02/24/堆随笔/","link":"","permalink":"http://yoursite.com/2018/02/24/堆随笔/","excerpt":"这篇博客的主要内容是对于堆的一些总结","text":"这篇博客的主要内容是对于堆的一些总结 1.创建堆首先堆这个对象的框架你要能够很清楚的记得，即私有成员是vecotr的容器比较好，还有一个就是size用来记录堆中的元素，这样可以用来盛放外界数组的元素，其构造函数主要的作用就是将外界数组元素保存到自己的容器中，然后如果你想创建小堆则用向下调整法，这样堆最开始的创建的就结束了。 2.向下调整法此方法用于建立小堆的时候可以使用，首先数组是根据完全二叉树的方式在数组中存储的，所以我们可以借助树的模型来简化我们的操作，首先需要找到倒数第一个叶子结点的父结点从这里开始调整,这个父结点的位置怎么找呢？举个例子找到父结点的位置以后开始进行调整，首先需要根据父结点在找出其孩子结点的位置，这个很好找就是父结点的位置*2+1就是孩子结点的位置，因为是向下调整发，所以需要判断左右孩子哪个大，找出最小的那个孩子，然后让他和父结点去比较，然后继续向下走继续比较，依此类推。再次我给出代码 // void _Adjustdown(size_t parent) // { // size_t child = parent * 2 + 1;//保存左孩子 // while (child &lt; _size)//在这里的条件给成child&lt;size比较好 // { // Compare s;//定义仿函数对象 // //if (child + 1&lt;_size&amp;&amp;_array[child] &gt;_array[child + 1])//找最小的孩子 // // ++child; // if (child + 1 &lt; _size&amp;&amp;s(_array[child], _array[child + 1]))//找最小的孩子 // ++child; // if (/*child&lt;_size*/s(_array[parent], _array[child])) // { // swap(_array[parent], _array[child]); // parent = child; // child = parent * 2 + 1; // } // else//已经交换好了 // { // break; // } // } // } 在上述代码我想想强调的只有两点： 1.在判断左右孩子的时候当心父结点是单支结点，所以要判断chil+1&lt;size 2.在判断父结点和孩子结点谁小的时候，要当心孩子就结点超出size的大小，需要判断child=0;i–);来循环调整 3.堆的插入操作堆的插入使用的是向上调整法，因为插入之前堆已经建立好了则意味着调整好了，所以插入一个新结点以后意味着，插入的那棵和那棵树的祖先可能会不满足堆的性质，所以只需要顺着那一个方向一直向上调整就可以了，和向下调整法的差别不大，不过这个没有for循环，因为不需要挨个调整呀。给出代码： // void _Adjustup(int child)//向上调整 // { // int parent =(child-1)&gt;&gt;1; // while (parent&gt;=0) // { // if (Compare()(_array[parent], _array[child]))//使用简单的比较器 // { // swap(_array[parent], _array[child]); // child = parent; // parent = (child - 1) &gt;&gt; 1; // } // else // break; // } // } // //}; 在这个算法中我要强调的就是： 1.首先要根据孩子结点找到父结点2.循环的条件是parent&gt;=0 3.堆的pop堆的pop使用的算法有点乾坤大挪移的感觉，将堆顶元素和最后一个元素互换，然后使size–，然后使用向下调整法就解决了，是不是很奇妙 // void Heap_del()//删除堆顶的元素 // { // if (_array.empty()) // return;//空的话直接返回 // int size_last = _size - 1; // swap(_array[0], _array[size_last]); // _array.pop_back();//弹出去 // _size--; // if (_size &gt; 0) // { // _Adjustdown(0); // } // } 重点：1.从头开始调整，但是不需要循环调整！这里就牵扯到了你的向下调整的for循环是写在哪里了。 4.堆排序堆排序的思路也很简单主要是利用堆的性质，如果你要升序排序的话建立大堆，你要降序排序的话建立小堆，然后和删除的思路基本一致，首尾互换然后size– // void Head_Sort() // { // while (_size &gt; 1) // { // swap(_array[0], _array[_size - 1]); // //这里和删除的区别只是不弹出 // --_size; // _Adjustdown(0); // } // } 注意：这里和删除的区别就是不用弹出元素.还有就是break可以直接换成return; 5.优先级队列如何用堆来建立优先级队列呢？首选封装优先级队列的对象里面的成员就是堆，然后只需要使用堆的插入和删除就可以实现优先级队列了。 关于堆的优化就是加入仿函数。","categories":[{"name":"数据结构随笔","slug":"数据结构随笔","permalink":"http://yoursite.com/categories/数据结构随笔/"}],"tags":[{"name":"heap","slug":"heap","permalink":"http://yoursite.com/tags/heap/"}]},{"title":"sizeof详解","slug":"sizeof详解","date":"2018-02-24T07:42:50.000Z","updated":"2018-02-24T13:14:35.584Z","comments":true,"path":"2018/02/24/sizeof详解/","link":"","permalink":"http://yoursite.com/2018/02/24/sizeof详解/","excerpt":"首先对于sizeof做一个简单的介绍让你知道什么是sizoef，从心里对它有个大致的印象。","text":"首先对于sizeof做一个简单的介绍让你知道什么是sizoef，从心里对它有个大致的印象。 定义： sizeof是C/C++中的一个操作符（operator），简单的说其作用就是返回一个对象或者类型所占的内存字节数。 MSDN上的解释为：The sizeof keyword gives the amount of storage, in bytes, associated with a variable or a type(including aggregate types). This keyword returns a value of type size_t. 其返回值类型为size_t，在头文件stddef.h中定义。这是一个依赖于编译系统的值，一般定义为 typedef unsigned int size_t; 好了现在你应该对于sizoef有了一个大概的认识了，现在我们来看看sizoef的基本用法： sizeof(对象）； sizeof(类型）； sizeof 对象；//这个主意和1区分 对于上面的三种用法，其实你只需要掌握sizoef()的这种用法就够了，另外一个自己知道就可以了，因为根本没人去那么用。好了划重点了：记住sizeof计算对象的大小也是转换成对应的类型来计算的，这句话的言外之意就是不同的对象如果类型一样的话，sizoef计算的值是一样的。 用法： 接下来我就所说sizeof的一些应用场景和用法 1 sizeof对一个表达式求值注意：对于表达式求值，编译器会根据表达式结果的类型来计算，一般不会对表达式进行计算 举例如下： int fun(int a) { cout &lt;&lt; &quot;fun::sizoef&quot; &lt;&lt; endl; return a; } void test() { cout &lt;&lt; sizeof(fun(4)); } 此例子的输出就是 4，不会输出fun::sizeof,证明函数没有执行。 2.sizoef的常量性sizeof的计算是放生在编译期间的，所以其可以被当做常量表达式使用 举例如下： int n=10; int arr[sizeof(n)]; 3.sizeof和指针变量注意：当sizoef的对象是指针变量的时候，它的结果和指针所指的内容没有任何的关系，所以在32位计算机中指针变量是4,64位计算机中是8 4.sizeof和数组sizoef的数组的值等于数组所占的内存字节数，这里我在CSDN的博客写的很清楚了，感兴趣的可以自己去看http://blog.csdn.net/it_iverson/article/details/74733426 这里还要强调的一个重点就是数组传参的时候。 void fun(int arr[]) { cout &lt;&lt; sizeof(arr); } void test() { int arr[10] = { 0 }; fun(arr); } 这里的sizoef的输出是4而不是40，因为在函数的形参那里arr已经不是数组类型了，而是蜕变成了指针。相当于int *arr,因为数组是传址传参的，只是把数组首地址传过去了，所以接受地址的自然就是指针变量了，那么正如上文所说，指针变量的大小和其指向的内容没有关系，所以大小为4 5.sizeof和结构体这里主要强调的是结构体内存对其的一些知识在CSDN的博客中也有详细说明 http://blog.csdn.net/it_iverson/article/details/74790127 6.含有位字段的结构体 注意：单独的位字段成员不能被sizeof求值 那么什么是为字段呢？ 位字段是C语言中一种存储结构，不同于一般结构体的是它在定义成员的时候需要指定成员所占的位数。主要应用于嵌入开发 如下： struct stu { char a : 4;//占4位 char b : 3;//占3位 char c : 8;//占8位 };//大小为两个字节 在这里要注意的是： 1.如果相邻的位字段的类型相同，且其位数之和小于自身类型数，则后面的字段和紧挨着前面的字段存储，直到这个不能容纳为止 2.如果相邻的位字段类型相同，且其位数之和大于自身的类型数，则后面的字段从新的存储单元开始。 3.如果相邻位字段类型不同，则根据编译器的不同，是否采取压缩存储就不一定了。 4.如果位字段之间穿插着非为字段，则不进行压缩存储 7.sizeof和联合体因为联合体是重叠式存储，各成员共享一段内存，所以整个联合体的大小就是最大成员所占的空间的大小，假如联合体中有一个结构体成员，那么这个联合体的大小就是这个结构体的大小。","categories":[{"name":"c/c++","slug":"c-c","permalink":"http://yoursite.com/categories/c-c/"}],"tags":[{"name":"sizeof","slug":"sizeof","permalink":"http://yoursite.com/tags/sizeof/"}]}]}