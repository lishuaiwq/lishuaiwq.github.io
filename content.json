{"meta":{"title":"Lishuai's博客","subtitle":null,"description":"承载着太多希望，怎敢轻易辜负","author":"李帅","url":"http://yoursite.com"},"pages":[{"title":"关于博主","date":"2018-02-24T11:36:41.000Z","updated":"2018-02-24T12:46:34.022Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"博主是一个正在努力进步的小菜，欢迎大家一起来交流学习！"},{"title":"分类","date":"2018-02-24T11:38:30.000Z","updated":"2018-02-24T12:44:22.899Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-02-24T11:37:58.000Z","updated":"2018-02-24T12:45:30.238Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"TCP三次握手四次挥手","slug":"TCP三次握手四次挥手","date":"2018-03-27T08:11:52.000Z","updated":"2018-03-27T12:36:29.152Z","comments":true,"path":"2018/03/27/TCP三次握手四次挥手/","link":"","permalink":"http://yoursite.com/2018/03/27/TCP三次握手四次挥手/","excerpt":"首先来看一下TCP传输协议的报文格式中关于建立连接需要用到的一些比较重要的标志位。","text":"首先来看一下TCP传输协议的报文格式中关于建立连接需要用到的一些比较重要的标志位。 1.seq:32位序列号，占四个字节，范围在[0-2^32-1],因为TCP是面向字节流的，所以它需要为发送流中的每个字节编号，这个序列号是使用随机数产生器产生的。（只产生一次，后面顺序向上递增） 2.ACK：32位确认序号,仅当保留位旁边的ACK=1的时候确认序号才生效，其表示一个进程已经正确接收序列号为N的字节，要求下一次接收的应该是N+1序列号的字节，所以如果接收到了序列号为N，则ACK回复为N+1(注意和确认ACK位区分) 3.SYN:（同步位）同步序列号，用来发起一个连接，当SYN=1，ACK=0的时候，表示这是一个发起连接的报文请求段。如果对方同意建立连接则会回应SYN=1，ACK=1。（系统规定SYN=1的报文段不能携带数据，但是要消耗掉一个序列号） 4.FIN：（终止位）,终止位用来终止连接，当FIN=1,表示发送端的报文发送完毕，请求关闭连接。 好了下面来谈谈三次握手的建立连接的过程. 1.首先客户端和服务器端都处于CLOSE状态（关闭状态），并且服务器端已经创建了传输控制块TCB，即时刻准备接收客户端的请求，即服务器端就进入了LISTEN（监听状态）状态 2.客户端运行起来以后，也创建了传输控制块PCB，然后向B发送了连接请求的报文。这个报文首部的SYN标志位被设置成1，即SYN=1，同时随机选择一个初始的序号，这里假设为x,即seq=x(系统规定SYN=1的报文段不能携带数据，但是要消耗一个序列号)，当这个报文发送出去以后，客户端就有CLOSE变成了SYN_SENT状态（同步已经发送的状态） 3.服务器端接收到客户端发来的请求建立连接的报文请求得话则，则向A发送确认报文（也不带数据）。这个回复的报文中SYN=1,seq=y,ACK=x+1（确认序列号），告诉客户端你发的建立请求得要求我收到了，我同意和你建立请求，然后发送完后服务器端进入了SYN_RCVD的状态（准备接收，也可以说同步收到） 4.当客户端收到了服务器的同意建立连接请求后，还要给服务器端回应我收到了你的同意建立连接的报文,回复给服务器的报文是ACK=y+1,seq=x+1, TCP的标准规定，ACK的报文段可以携带数据。但如果不携带数据则不消耗序号，在这种情况下，下一个数据报文段的序号仍是seq = x+1。这时TCP连接已经建立，客户端进入ESTABLISHED（已建立连接）状态。当服务器收到收到客户端的确认后报文后，也进入ESTABLISHED状态。 致此整个连接建立的过程就完了，下面我来画个图说明一下 看图就是这么简单。。。。 下面来说一下四次挥手断开连接 在他们通信完成以后，双方还都是ESTABLISHED状态，并且断开连接的请求服务器和客户端都可以发起，我们这里说一下客户端先发起断开连接的请求。 1.当客户端准备结束这次的数据传输的时候，主动提出释放TCP连接时，它向服务器发送一个连接释放请求的报文，FIN=1，seq=u,(这里的u等于之前传送的数据最后一个字节的序列号+1)，然后客户端进入FIN_WAIT_1(释放等待1的状态,等待服务器端的确认),TCP规定：FIN报文段即使不携带数据，也要消耗掉一个序号。 2.当服务器端收到客户端的请求断开连接的报文后，需要向客户端发出已收到断开连接的报文请求得确认报文，ACK=u+1，seq=v（v表示服务器端之前发送的最后的数据的最后一个字节的序列号+1）,然后服务器进入CLOSE_WAIT状态。 注： TCP服务器进程此时应该通知高层应用进程，因为从A到B这个方向的连接已经关闭，这时的TCP进程属于半关闭（half_close）状态，即客户端已经不会给服务器发送数据了，但服务器要向客户端发送数据，客户端还得接收。 3.当客户端收到服务器发来的ACK（确认断开连接报文后），进入FIN_WAIT_2的状态（释放等待2的状态，等待服务器端发送断开连接的请求），如果服务器端没有数据要发送了，应用程序通知服务器发送断开连接的请求，即向客户端发送断开连接的请求报文FIN=1,seq=w(假设客服端发送断开连接请求以后，服务器还给客户端发送消息了)，并且还要重复确认之前的ACK=u+1,然后服务器就进入了LAST_ACK状态（等待客户端回应自己的断开连接请求） 4.当客户端收到了服务器发来的要断开连接的请求后，回复给服务器ACK=w+1,seq=u+1,然后进入TIME_WAIT等待时间的状态，但是，现在TCP连接还没有释放，必须经过时间等待计时器（TIME_WAIT timer）设置的时间2MSL后，A才能进入到CLOSED状态。 下面画出示意图： 这里说一下这个TIME_WAIT： 为了保证TCP连接释放过程的正常进行，TCP设置了时间等待器即TIME_WAIT timer.这个时间一般是2MSL（两个最长报文寿命时间），这个时间过后客户端才能真正进入CLOSE状态。 TCP状态转换图 CLOSED：表示初始状态。 LISTEN：该状态表示服务器端的某个SOCKET处于监听状态，可以接受连接。 SYN_SENT：这个状态与SYN_RCVD遥相呼应，当客户端SOCKET执行CONNECT连接时，它首先发送SYN报文，随即进入到了SYN_SENT状态，并等待服务端的发送三次握手中的第2个报文。SYN_SENT状态表示客户端已发送SYN报文。 SYN_RCVD: 该状态表示接收到SYN报文，在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂。此种状态时，当收到客户端的ACK报文后，会进入到ESTABLISHED状态。 ESTABLISHED：表示连接已经建立。 FIN_WAIT_1: FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。区别是：FIN_WAIT_1状态是当socket在ESTABLISHED状态时，想主动关闭连接，向对方发送了FIN报文，此时该socket进入到FIN_WAIT_1状态。 FIN_WAIT_2状态是当对方回应ACK后，该socket进入到FIN_WAIT_2状态，正常情况下，对方应马上回应ACK报文，所以FIN_WAIT_1状态一般较难见到，而FIN_WAIT_2状态可用netstat看到。 FIN_WAIT_2：主动关闭链接的一方，发出FIN收到ACK以后进入该状态。称之为半连接或半关闭状态。该状态下的socket只能接收数据，不能发。 TIME_WAIT: 表示收到了对方的FIN报文，并发送出了ACK报文，等2MSL后即可回到CLOSED可用状态。如果FIN_WAIT_1状态下，收到对方同时带 FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。 CLOSING: 这种状态较特殊，属于一种较罕见的状态。正常情况下，当你发送FIN报文后，按理来说是应该先收到（或同时收到）对方的 ACK报文，再收到对方的FIN报文。但是CLOSING状态表示你发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什么情况下会出现此种情况呢？如果双方几乎在同时close一个SOCKET的话，那么就出现了双方同时发送FIN报文的情况，也即会出现CLOSING状态，表示双方都正在关闭SOCKET连接。 CLOSE_WAIT: 此种状态表示在等待关闭。当对方关闭一个SOCKET后发送FIN报文给自己，系统会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，察看是否还有数据发送给对方，如果没有可以 close这个SOCKET，发送FIN报文给对方，即关闭连接。所以在CLOSE_WAIT状态下，需要关闭连接。 LAST_ACK: 该状态是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，即可以进入到CLOSED可用状态。 2MSL存在理由？ 在客户端发送出最后的ACK回复，但该ACK可能丢失。服务器如果没有收到ACK，服务器将不断重复给客户端发送FIN片段。所以客户端不能立即关闭，它必须确认服务器接收到了该ACK。客户端会在发送出ACK之后进入到TIME_WAIT状态。客户端会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么客户端会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，客户端都没有再次收到FIN，那么客户端推断ACK已经被成功接收，则结束TCP连接。 第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。 RFC 793中规定MSL为2分钟，实际应用中常用的是30秒，1分钟和2分钟等 为什么建立是三次握手，断开时四次握手呢？ 这是因为服务端的LISTEN状态下的SOCKET当收到SYN报文的建立连接请求后，它可以把ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一 个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但你所有的数据未必都全部发送给对方了，所以你未必会马上会关闭SOCKET,即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。 如果已经建立了连接，但是客户端突然出现故障了怎么办？ TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75分钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。 为什么不能用两次握手进行连接？ 不用三次的话，server不能确定client是否收到自己的消息如果没有收到，可能client根本没收到，或者client响应了，但server没收到","categories":[{"name":"网络学习","slug":"网络学习","permalink":"http://yoursite.com/categories/网络学习/"},{"name":"传输层","slug":"网络学习/传输层","permalink":"http://yoursite.com/categories/网络学习/传输层/"}],"tags":[{"name":"传输层","slug":"传输层","permalink":"http://yoursite.com/tags/传输层/"}]},{"title":"Linux-信号","slug":"Linux-信号","date":"2018-03-26T03:42:02.000Z","updated":"2018-03-26T12:05:32.676Z","comments":true,"path":"2018/03/26/Linux-信号/","link":"","permalink":"http://yoursite.com/2018/03/26/Linux-信号/","excerpt":"此篇博客对于Linux中信号的相关知识点做介绍。 一.信号的概念什么是信号呢?","text":"此篇博客对于Linux中信号的相关知识点做介绍。 一.信号的概念什么是信号呢? 信号怎么说呢？比如古代的摔杯为号，比赛名枪为号，这都是信号。 这些信号都有一个共同的特性，那就是简单、不能携带大量信息，满足一点条件时才产生。 信号是软件中断，很多重要的程序的需要处理信号，信号提供了一种异步事件的方法，所以是系统中必不可少的东西！ Unix早期版本就提供了信号机制，但不可靠，信号可能丢失。Berkeley 和 AT&amp;T都对信号模型做了更改，增加了可靠信号机制。但彼此不兼容。POSIX.1对可靠信号例程进行了标准化。 信号的机制：A给B发送信号，B收到信号之前执行自己的代码，收到信号后，不管执行到程序的什么位置，都要暂停运行，去处理信号，处理完毕再继续执行。与硬件中断类似——异步模式。但信号是软件层面上实现的中断，早期常被称为“软中断”。 信号的特质：由于信号是通过软件方法实现，其实现手段导致信号有很强的延时性。但对于用户来说，这个延迟时间非常短，不易察觉。 首先来看一下Linux中的一些信号。这是linux系统中的提供的一些信号，一共是62个不是64个，但是我们只需要掌握了解1-31号信号（非实时信号，不可靠信号，不支持排队，容易丢失），34-64序列的信号是驱动层次的信号（实时信号，可靠信号，支持排队，不会丢失），我们一般接触不到！ 二.信号的产生方式1.当用户按某些中断键时，引发终端产生对应的信号，比如ctrl +c.这里详细说一下：当我们在shell下启动一个前台进程，这个时候当用户在键盘上按下ctrl+c,这个时候键盘输入产生一个硬件中断，如果当前cpu正在执行这个进程的代码，则该进程的用户空间代码暂停执行，cpu从用户态切入内核态处理硬件中断，终端驱动程序将ctrl+c解释成一个SIGINT信号，将这个信号记录在这个前台进程的pcb中，当某个时候准备从内核返回到该用户空间代码的时候，首先检查pcb中的记录，发现有信号SIGIN未处理，而且发现这个信号的处理动作是默认动作，因为其默认动作是终止进程，那么将直接终止进程而不再返回它的用户空间去执行刚才未执行完的代码。 注意：按键产生方式产生的信号只能发给前台进程。因为前台程序在执行的过程中用户随时可以按下组合件所以这体现了信号具有异步性。 还要说明一个问题那就是Core Dump，有的信号的默认处理动作是结束进程，但是有的信号在结束进程的同时并且Core Dump，下面解释一下Core Dump :当一个进程要异常终止的时候，可以选择把进程的用户空间内的数据全部保存在磁盘上，这个保存数据的文件名是core,这个动作就是Core Dump。进程异常终止的原因一般来说是有BUG,所以我们可以通过这个文件来找出我们的错误出在了哪里。。。但是系统默认是不支持core文件产生的，因为其中会保存关系用户密码等敏感信息，不安全，如果我们想使用的话需要用ulimit来进行设置。 接下来我们写一个死循环程序，让其在前台运行，然后通过ctrl+\\产生SIGQUIT（能产生core文件的信号） 需要找bug的话，使用gdb core-file +core文件，程序会自动跳到出错的地方 2.硬件异常产生的信号比如除数为0，无效的内存引用等。这些条件通常由硬件检测到，并通知内核，然后内核为产生该条件的进程发送一个信号（这里的发送其实实质上指的是在进程的PCB中做一些记录，后面我们在详细去讲） 3.调用系统函数向进程发送信号1.使用kill函数（man 2 kill可查看） #include &lt;sys/types.h&gt; #include &lt;signal.h&gt; int kill(pid_t pid, int sig); 成功返回0，失败-1 说明： id &gt; 0: 发送信号给指定的进程。 pid = 0: 发送信号给 与调用kill函数进程属于同一进程组的所有进程。 pid &lt; 0: 取|pid|发给对应进程组。 pid = -1：发送给进程有权限发送的系统中所有进程。 进程组：每个进程都属于一个进程组，进程组是一个或多个进程集合，他们相互关联，共同完成一个实体任务，每个进程组都有一个进程组长，默认进程组ID与进程组长ID相同。权限保护：super用户(root)可以发送信号给任意用户，普通用户是不能向系统用户发送信号的。 kill -9 (root用户的pid) 是不可以的。同样，普通用户也不能向其他普通用户发送信号，终止其进程。 只能向自己创建的进程发送信号。普通用户基本规则是：发送者实际或有效用户ID == 接收者实际或有效用户ID 2.使用kill命令（man 1 kill可查看）,此命令只是kill函数的一个借口，用来终止一个失控的后台程序 3.raise函数：给当前进程发送指定信号，自己给自己发 #include &lt;signal.h&gt; int raise(int sig); 成功返回0，失败返回-1 4.abort函数：自己给自己发送异常终止信号6）SIGARBT，终止自己并产生core文件 #include &lt;stdlib.h&gt; void abort(void); 因为这个函数和exit一样总会 成功执行，所以没有返回值 4.由软件条件产生的信号比如SIGPIPE，不过这次要重点介绍alarm函数 #include &lt;unistd.h&gt; unsigned int alarm(unsigned int seconds); 调用alarm函数可以给当前进程设置一个闹钟，也就是告诉内核早seconds秒之后给当前进程发送SIGALRM信号，该信号的默认处理动作是将当前进程终止。每个进程都有仅且唯一的一个定时器。 这个函数返回值如果是0，则说明闹铃正确设置并且只有一个闹铃，如果你当前已经设置了一个闹铃了，那么alarm(0)，表示取消之前所设置的闹铃，返回之前闹铃剩余的时间。假如在次使用alarm(10)，则表示重新设置闹铃为10秒，并且此时的闹铃返回之前 设置闹铃的剩余时间。 另外设置闹铃和进程的状态无关。使用time+可执行程序可以查看程序的执行时间。 另外除了alarm可以设置闹铃以外。setitimer函数也可以设置闹铃，并且它的计时功能更加的齐全。感兴趣的自己了解，，，这块我后面再补充吧。 三.信号在内核中的表示方法和信号的处理方法1.信号内核中的表示 block:是用来设置信号屏蔽的，如果里面对应的是1则表示该信号产生了，并且被屏蔽不能抵达，即如果block里面是1则,pending里面一定是1 pending:表示产生了一个信号。 默认执行动作：表示这个信号一旦抵达根据默认执行动作的指示执行相关动作，如果用户自己设置了捕捉函数的话，则将执行用户指定的函数。SIG_DFL：表示指针默认动作SIG_IGN:表示忽略此信号 注意：一个信号一旦被阻塞，如果在这信号阻塞期间多次产生这个信号的话，如果这个信号不是实时信号的话，则只记录一次，如果是实时信号的话，则将所有产生的信号放在一个队列里。 2.信号处理方法 1.执行其默认动作 2.忽略 3.用户自定义函数捕捉。 四.信号集操作函数内核通过读取未决信号集来判断信号是否应被处理。信号屏蔽字mask可以影响未决信号集。而我们可以在应用程序中自定义set来改变mask。已达到屏蔽指定信号的目的。 所以引入一种类型sigset_t 表示信号集类型，我们可以通过这个类型定义信号集变量，通过一些信号集操作函数来影响信号屏蔽字从而达到屏蔽指定信号的目的。 1.下面来介绍一下信号集的操作函数 #include &lt;signal.h&gt; int sigemptyset(sigset_t *set);//将自定义信号集所有位清为0 int sigfillset(sigset_t *set);//将自定义的信号集所有位清为1 int sigaddset(sigset_t *set, int signum);//将指定信号加入信号集 int sigdelset(sigset_t *set, int signum);//将指定信号从信号集中删除 int sigismember(const sigset_t *set, int signum);//判断某个信号是否在信号集中 这些函数都是成功返回0，错误返回-1，最后一个函数是一个布尔函数。 既然我们自定义的信号集已经设置好了，那么如何通过自定义的信号集取影响内核的信号屏蔽字呢？ 2.使用sigprocmask函数 #include &lt;signal.h&gt; int sigprocmask(int how, const sigset_t *set, sigset_t *oldset); 成功返回0，出错返回-1 参数 1.how有三个取值b，分别表示自定义的信号集和内核的信号屏蔽字做什么样的操作，即如果影响内核的信号屏蔽字 SIG_BLOCK：表示mask=mask | set,即将我们希望添加屏蔽的信号添加到信号屏蔽字当中去 SIG_UNBLOCK：表示mask=mask &amp;~ set ,表示我们想将信号屏蔽字中的哪些信号解除阻塞 SIG_SETMASK：表示mask=set，将内核中的信号屏蔽字的值替换为我们自己定义的值 2.set:表示我们自己定义的信号集 3.oldset:保存更改前的信号屏蔽字的值，可以为空 如果调用sigprocmask解除了对当前若干个未决信号的阻塞，则在sigprocmask返回前，至少将其中一个信号抵达 3.sigpending：读取当前未决信号集，由set传出 #include &lt;signal.h&gt; int sigpending(sigset_t *set); 五.信号捕捉函数1.signal #include &lt;signal.h&gt; typedef void (*sighandler_t)(int); sighandler_t signal(int signum, sighandler_t handler); 参数signum:表示要捕捉的信号 handlrt:表示要执行的捕捉动作，可以看出其实函数指针 2.signaction #include &lt;signal.h&gt; int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact); 在这里只关系我标记星星的三个成员 参数： signum:表示要捕捉的信号 sa_handler:表示执行的捕捉动作 sa_mask表示在函数调用期间所要屏蔽的信号的信号集 sa_flag=0，系统默认设置 此函数的信号捕捉函数执行的时候，sa_mask中屏蔽的信号多次发过来的话，则等处理函数处理完只执行一次，在捕捉函数执行期间，信号屏蔽字由sa_mask决定！ 信号在 内核中的捕捉过程 当一个进程发生某种异常中断后，这个时候系统切换到内核状态处理中断，然后在要返回的时候检查进程有信号抵达，并且用户设置了自定义的信号捕捉函数，则内核调用handle_signal（）函数从而回到用户态去调用用户自定义的信号处理函数（这期间需要使用setup_frame或setup_rt_frame来为信号处理函数设置栈)，当内核回到用户态执行完用户自定义的处理函数以后，位于 setup_framesetup_rt_frame栈之上的返回代码(return code)被执行,这返回代码会执行sigreturn，再次进入内核回到上次从内核转到用户态的位置，然后返回用户态执行刚才主函数中断的 代码的下面的指令。 六.时序静态问题介绍时序静态之前就要说一下pause函数 #include &lt;unistd.h&gt; int pause(void); pause函数使进程挂起直到有信号抵达，如果信号的处理动作是终止进程，则进程终止，pause函数没有机会返回，如果信号处理动作是忽略，那么pause继续处于挂起状态不返回；如果信号的处理动作是捕捉，则调用了信号处理函数之后则pasue返回-1,errno设置EINTR，所以pause只有出错返回值！EINTR表示被信号中断。 时序静态问题是： 注册SIGALRM信号处理函数 （sigaction…)调用alarm(1) 函数设定闹钟1秒。 2.函数调用刚结束，开始倒计时1秒。当前进程失去cpu，内核调度优先级高的进程(有多个)取代当前进程。当前进程无法获得cpu，进入就绪态等待cpu。 3.1秒后，闹钟超时，内核向当前进程发送SIGALRM信号(自然定时法，与进程状态无关)，高优先级进程尚未执行完，当前进程仍处于就绪态，信号无法处理(未决) 优先级高的进程执行完，当前进程获得cpu资源，内核调度回当前进程执行。SIGALRM信号递达，信号设置捕捉，执行处理函数sig_alarm。 5.信号处理函数执行结束，返回当前进程主控流程，pause()被调用挂起等待。（欲等待alarm函数发送的SIGALRM信号将自己唤醒） SIGALRM信号已经处理完毕，pause不会等到。 即简单讲就是alarm和pause之间失去了cup的时候alarm发出了信号，当cpu切回来的时候捕捉了这个信号，这个时候pause才挂起，即变成了永久挂起。 问题就是我们想到了在pause挂起之前设置屏蔽SIGALLRM这个信号，这样就不会提前处理了，在pause挂起的时候在解除屏蔽。可是这样的话在解除屏蔽的时候cpu又被切走了,那么一样会永久挂起。所以要解决这个问题，就需要将解除屏蔽和pause挂起设置为一个原子操作，即中间不会失去cpu。这就需要我们用到这个函数 1.sigsuspend #include &lt;signal.h&gt; int sigsuspend(const sigset_t *mask); 这个函数的作用是，在调用sigsuspend函数的时候，进程的信号屏蔽字由其传入的mask决定，然后挂起等待，当sigsuspend返回的时候即信号屏蔽字恢复为原来的进程的值。 这个函数怎么用呢？ 我们可以进程原来的信号屏蔽字设置为屏蔽SIGALRM，这样的话无论你什么时候cpu切出去，切多久，你如果产生了SIGALRM信号的话，那么系统也不处理，当回来以后sigsuspend挂起后，这个时候将其中的信号屏蔽字并没有屏蔽SIGALRM信号，则立刻处理，然后结束挂起。这样就可以实现解除屏蔽和挂起的原子性从而解决时序竟态的问题 七.可重入函数一个函数在被调用执行期间(尚未调用结束)，由于某种时序又被重复调用，称之为“重入”。根据函数实现的方法可分为“可重入函数”和“不可重入函数”两种 注意事项1.定义可重入函数，函数内不能含有全局变量及static变量，不能使用malloc、free 2.信号捕捉函数应设计为可重入函数 3.信号处理程序可以调用的可重入函数可参阅man 7 signal 4.没有包含在上述列表中的函数大多是不可重入的，其原因为： a)使用静态数据结构 b)调用了malloc或free c)是标准I/O函数 八.SIGCHLD子进程在终止的时候会给父进程发送SIGCHLD信号，该信号的默认处理动作是忽略，父进程可以自定义SIGCHLD捕捉函数，在里面来回收子进程了。这样就弥补了wait的一直阻塞和waitpid的轮询回收缺点。 其实要想不产生僵尸进程还有另外一种办法就是父进程调用信号捕捉函数sigaction将SIGCHLD设置SIG_IGN，这样fork出来的子进程在终止时会自动清理掉，不会产生僵尸进程，也不会通知父进程。对于系统的默认胡洛和我们自己设置的忽略一般来说是没有区别的，但是就是这个比较特殊。同样是忽略，结果却不一样，此方法只对于Linux可用。 相关代码上传至github: https://github.com/lishuaiwq/Linux-System-programming/blob/master/signal/my_sleep_sigsuspend.c","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"},{"name":"系统编程","slug":"Linux/系统编程","permalink":"http://yoursite.com/categories/Linux/系统编程/"}],"tags":[{"name":"信号","slug":"信号","permalink":"http://yoursite.com/tags/信号/"}]},{"title":"Linux进程间通信(IPC)","slug":"Linux进程间通信","date":"2018-03-22T13:48:23.000Z","updated":"2018-03-25T02:41:50.329Z","comments":true,"path":"2018/03/22/Linux进程间通信/","link":"","permalink":"http://yoursite.com/2018/03/22/Linux进程间通信/","excerpt":"关于进程间通信就不多说了，接下来对于Linux间的进程通信的一些方式进行介绍，主要方式有下面的几种 管道 消息队列 共享内存 信号量 在这里要说要一下我们这里的消息队列、共享内存、信号量是System V版本下面的IPC，注意和POSIX区别。下面我来一个一个详细介绍","text":"关于进程间通信就不多说了，接下来对于Linux间的进程通信的一些方式进行介绍，主要方式有下面的几种 管道 消息队列 共享内存 信号量 在这里要说要一下我们这里的消息队列、共享内存、信号量是System V版本下面的IPC，注意和POSIX区别。下面我来一个一个详细介绍 一.管道管道是UNIX系统IPC的最古老的方式，所有UNIX系统都提供这种通信机制。管道分为匿名管道(pipe)和命名管道(fifo) 1.匿名管道：作用于有血缘关系的进程间通信，完成数据的传送，调用pipe系统函数即可创建一个匿名管道。 #include&lt;unistd.h&gt; int pipe(int pipefd[2]) 正确返回0，错误返回-1，并且设置errno值。 其本质是一个伪文件（实质是内核的一个缓冲区） 有两个文件描述符引用，一个表示读端，一个表示写端 规定数据从管道的写端流入管道fd[1]，从读端流出管道fd[0] 采用半双工通信方式，即数据同一时刻只能在一个方向上流动 一般情况下一个进程先会调用pipe，然后调用fork(),从而创建从父进程到子进程的IPC通道。fork之后对于数据的流向取决于我们。如果我们想让父进程写数据，则将父进程的读端关闭，即关闭fd[0]，将子进程的写端关闭fd[1]，反之亦然。 我们进行相应端的关闭就可以进行通信了 对于管道最后有几点要强调的： 1.如果写端文件描述被关闭，则读端返回0 2.如果读端被关闭，则写端会产生信号SIGPIPE，写端进程结束 3.当要写入的数据不大于PIPE_BUF时，linux将保证写入的原子性，如果大于PIPE_BUF时，则不保证其写入的原子性。 4.一般而言进程退出，管道释放，所以管道的声明周期随进程。 2.命名管道对于匿名管道的应用有个限制就是只能应用于有血缘关系的进程，而命名管道恰好弥补了这个缺点，可以在两个不相干的进程间通信。 创建匿名管道的方式有两种： 1.命令创建，使用mkfifo fifoname,这就创建了一个名字为fifoname的命名管道,然后两个进程分别打开这个文件就可以通信了 2.使用mkfifo函数打开。 #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; int mkfifo(const char *pathname, mode_t mode); 成功返回0，失败返回-1，并设置errno。 命名管道的打开方式和打开的时候的一些问题这里强调一下： 1.如果没有设定open FIFO的O_NONBLOCK权限的话，那么当前打开的操作默认是会产生阻塞，即是读打开的FIFO的话，如果此时没有进程以写的方式打开同一个FIFO文件的话，那么当前进程阻塞，直到有进程以写的方式打开同一个FIFO，反之亦然！ 2.如果open FIFO的时候指定了 O_NONBLOCK则不阻塞。但是会产生一些问题。 如果是写进程设置了不阻塞，但是当写进程运行了时候没有于之对应的读进程运行的话，那么这个写进程的open操作会立马返回失败，错误号为ENXIO(6)，使用errno全局变量可以打印出来。 如果是读进程设置了不阻塞，运行时没有写进程与之对应，则读进程open成功，只不过以读取值为0而退出。 所以一般情况下，就默认阻塞就可以了。。。免得产生一堆麻烦 对于设置了阻塞标志的写操作： 当要写入的数据量不大于PIPE_BUF时，linux将保证写入的原子性。如果此时管道空闲缓冲区不足以容纳要写入的字节数，则进入睡眠，直到当缓冲区中能够容纳要写入的字节数时，才开始进行一次性写操作。当要写入的数据量大于PIPE_BUF时，linux将不再保证写入的原子性。FIFO缓冲区一有空闲区域，写进程就会试图向管道写入数据，写操作在写完所有请求写的数据后返回。 对于没有设置阻塞标志的写操作： 当要写入的数据量大于PIPE_BUF时，linux将不再保证写入的原子性。在写满所有FIFO空闲缓冲区后，写操作返回。当要写入的数据量不大于PIPE_BUF时，linux将保证写入的原子性。如果当前FIFO空闲缓冲区能够容纳请求写入的字节数，写完后成功返回；如果当前FIFO空闲缓冲区不能够容纳请求写入的字节数，则返回EAGAIN错误，提醒以后再写； 对于运行时的一些操作： 如果两个进程正在进行读写操作，这个时候读端关闭了，那么写端再写的话，写进程会产生一个SIGPIPE（13）的信号，意思是写入没有读端的操作，那么会将写进程终止掉。自己可以去捕捉验证。如果是写进程先关闭的话，那么会给读进程产生一个文件结束标志，即读进程以读取值为0方式退出！ （划重点了！考试要考！注意共享资源printf的刷新fflush(stdout)，不然会影响两边的输出,切记！！！！，还有FIFO也是半双工，想要互相通信的话那么记得创建两个fifo来通信） 关于fifo的使用自己去练习吧，这里就不贴多余的代码了。 二.消息队列消息队列是消息的链表，存储在内核中，由消息队列标识符标识！它是内核给我们提供的一种IPC的方式。首先给出一个大概的示意图 再来看看系统为我们维护的消息队列的结构 在/usr/include/linux/msg.h中查看对于结构体中的第一个结构体ipc_perm在这里 在这里查看/usr/include/linux/ipc.h 所以说系统大概是 这么维护我们这个消息队列的！ 先简单概括一下怎么使用消息队列吧： 1.得到_key,用来生成一个唯一的消息队列的秘钥，然后得到一个消息队列的标识符，用这个标识符来进行相关操作。下面来介绍一些关于消息队列的使用函数。 1.获取_key的函数#include &lt;sys/types.h&gt; #include &lt;sys/ipc.h&gt; key_t ftok(const char *pathname, int proj_id); ftok的功能就是由一个路径名字和项目ID产生一个key。 参数： pathname:就是你自己指定一个文件名（已经存在的文件名），一般情况用当前目录。（.） proj_id:是1-255之间的字符值,不能取0值 man文档的描述： ftok（）函数使用由给定路径名命名的文件的标识（它必须引用现有的， 可访问的文件）和proj_id的最低有效8位（它必须是非零）来生成key_t类型 System V IPC密钥，适用于msgget（2），semget（2）或shmget（2）。 其返回值成功我们的秘钥，失败返回-1，这样通过这个函数就得到了_key. 2.创建消息队列#include &lt;sys/types.h&gt; #include &lt;sys/ipc.h&gt; #include &lt;sys/msg.h&gt; int msgget(key_t key, int msgflg); 参数： 1.key就是我们的秘钥 2.生成消息队列的一些权限和打开文件时的一些权限是一样的一般来说取IPC_CREATE、IPC_EXCL。如果想要创建一个新的消息队列，并且确保这个消息队列独一无二，则msgflag设置成IPC_CREATE | IPC_EXCL,这样的话当有重复消息队列的时候就会报错返回EEXIST。 成功返回消息队列的表示符，可以理解为我们创建的消息队列的名字，失败返回-1，设置errno 在这里一般情况是服务器进程创建消息队列，客户端进程只要拿到消息队列的标识符就可以和服务器通过消息队列通信 3.消息队列的控制函数#include &lt;sys/types.h&gt; #include &lt;sys/ipc.h&gt; #include &lt;sys/msg.h&gt; int msgctl(int msqid, int cmd, struct msqid_ds *buf); 成功返回0，出错返回-1 参数： 1.msqid：就是我们通过msgget获得的消息队列的标识符，用这个标识符就可以操作消息队列。 2.cmd:表示对我们要操作的消息队列要进行的操作，有三个取值 IPC_STAT: 将与msqid相关联的内核数据结构的信息复制到指向的msqid_ds结构中buf中。调用者必须具有消息队列的读取权限 IPC_SET:将与msqid相关联字段中的某些值，设置为buf所关联的消息队列中的值。执行此命令的进程需要一定的权限限制 IPC_RMID：从内核中删除消息队列及其所有的数据。这种删除立即生效。删除后扔在使用此消息队列的进程对消息队列再次进行操作的时候，将得到EIDRM错误。这个命令的执行也需要进程有一定的权限。（这三个操作同样也可以用于信号量和共享内存） 3.buf就是我们自己定义的结构体 4.往消息队列中放消息 #include &lt;sys/types.h&gt; #include &lt;sys/ipc.h&gt; #include &lt;sys/msg.h&gt; int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg); 成功返回0，出错返回-1 在说这个函数之前，我们来看一下发送的消息的类型 是一个结构体里面的内容分别是消息的类型和消息的内容。消息的类型用来判断是客户端发的还是服务器发的，因为二者都在同一个消息队列中放数据不区别的话，很容易搞乱的！ 下面来看msgsnd的参数 1.msqid：消息队列的表示符 2.msgp:传入参数，表示指向我们所发送的消息，即上图中的消息的结构体类型 3.msgz:消息的长度，这个长度不包括结构体中消息类型的长度，仅仅是数据的长度 4.msgflg:控制着当前消息队列满或者到达系统上限时的处理方法。 magflg=IPC_NOWAIT:表示如果队列中的消息总数等于系统的限定值（消息结构体个数），或者消息队列中总的字节数等于系统限制，则立即出错返回EAGAIN. 如果没有指定magflg=NOWAIT的话，那么消息队列满了的话，则会一直阻塞到有空间可以容纳消息或者从系统中删除了这个消息队列或者收到某个信号，从信号处理返回程序。没有设置NOWAIT会返回EIDRM错误（消息队列被删除）或者返回EINTR错误（信号） 如果将消息队列删除了，那么再使用这个消息队列的进程会出错返回。 当msgnd函数成功返回的时候，msqid_ds中的内容会随之更新。 5.从消息队列中取消息#include &lt;sys/types.h&gt; #include &lt;sys/ipc.h&gt; #include &lt;sys/msg.h&gt; ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp,int msgflg); 参数： 1.msqid:消息队列的标识符 2.msgp:指向我们自定义用来接收消息的结构体(传入传出参数) 3.msgz:消息的长度，这个长度不包括结构体中消息类型的长度，仅仅是数据的长度 4.msgtyp:表示读取消息时候的一些优先级。 msgtype==0,返回消息队列中的第一条消息 msgtype&gt;0,返回消息队列中类型为msgtype的第一条消息（就是找我们指定的消息） msgtype&lt;0,返回消息队列中类型值小于msgtype的绝对值的消息，如果这种消息有很多，则返回其中类型值最小的。（我觉得一般多个进程使用一个消息队列通信才会用到） 5.msgflg:如果队列中没有对应类型的消息将会发生的事 msgflg=IPC_NOWAIT,没有对应消息的时候不等待，返回ENOMSG错误 msgflg=MSG_NOERROR,消息大小超过magsz时被截断 msgflg=MSG_NOERROR并且msgtype&gt;0，接收类型不等于msgtype的第一条消息。 三.共享内存先用一张图来解释吧 共享内存就是一块物理内存可以映射到多个继承的共享区，那么每个进程都可以访问这块共享区，而且一个进程对这块区域的数据进行了了修改的坏，那么其他的进程都能看见，这就不需要将数据在两个进程之间复制来复制，不用进入内核，而直接实现通信，所以这是IPC最快的通信方式，但是只要多个进程对于共享区访问，就会出现同步互斥的问题，这是我们在使用共享内存唯一需要注意的地方，当然这个问题可以使用互斥锁和信号去解决。下面我们先来看看怎么使用共享内存实现进程间的通信。 首先系统为内存的你要的那块共享区域维护着一个数据结构在/usr/include/linux/shm.h中查看 我们同样可以看到个数据成员是ipc_perm，则说明我们想要创建一个共享内存则也需要一个独一无二的秘钥，即需要使用ftok函数。 1.使用ftok获取key秘钥2.创建共享内存#include &lt;sys/ipc.h&gt; #include &lt;sys/shm.h&gt; int shmget(key_t key, size_t size, int shmflg); 成功返回共享内存标识符，失败返回-1 参数： 1.key：用来创建共享内存的秘钥 2.size:共享内存的大小，以字节为单位 3.shmflg：创建时的一些权限比如IPC_CREAT、IPC_EXCL 3.将共享内存段连接到进程的虚拟地址空间 #include &lt;sys/types.h&gt; #include &lt;sys/shm.h&gt; void *shmat(int shmid, const void *shmaddr, int shmflg); 成功返回一个指针，指向共享内存的第一个字节（共享区的内存），失败返回-1 参数： 1.shmid:共享内存的标识符（物理内存） 2.shmaddr:指定连接的地址，即自己定义在虚拟内存中的地址，但是其又和shmflag参数有关系 3.shflag:其有两个取值，SHM_RND（表示取整的意思）或者SHM_RDONLY（只读） 当shmaddr==NULL,核心自动选择一个地址,用返回值返回 当shmaddr!=NULL,并且shflag没有设置SHM_RND标记，则以shmaddr为连接地址 当shmaddr!=NULL,且shmflag设置了SHM_RND标记，则连接的地址会自动向下调整为SHMLBA的整数倍。（公式：shmaddr-(shmaddr%SHMLBA)），SHMLBA意思是“低边界地址倍数，总是2的乘方”。 当shflag==SHM_RDONLY,表示连接操作用来只读共享内存，不具备写的操作。否则具备读写的权限。 一般情况下都将shmaddr设置为0，由系统去选择地址。如果shmat调用成功，则shmid_ds结构中的计数器+1。如果一个进程使用完了共享内存，则应该调用shmdt将其映射关系分离，那么shmid_ds中的计数器就会-1，但是这个分离操作并不会删除我们之前在内存中创建的共享内存，这需要我们手动去删除。 4.将共享内存段与当前进程脱离关系#include &lt;sys/types.h&gt; #include &lt;sys/shm.h&gt; int shmdt(const void *shmaddr); 成功返回0，失败返回-1 参数： shmaddr:建立的连接地址，即由shmat返回的地址。特别注意脱离关系不代表删除了共享内存。 5.用于控制共享内存（内存中的共享内存） #include &lt;sys/ipc.h&gt; #include &lt;sys/shm.h&gt; int shmctl(int shmid, int cmd, struct shmid_ds *buf); 成功返回0，失败返回-1 参数： 1.shmid：共享内存的标识符 2.cmd:将要采取的处理动作，有三个值。 3.自己定义的struct shmid_ds *buf结构体 当cmd==IPC_STAT：把自定义shmid_ds结构中的数据设置为共享内存当前的关联值 当cmd==IPC_SET:把共享内存的 shmid_ds设置为自定义的 shmid_ds的值 当cmd==IPC_RMID:删除共享内存。因为shmid_ds中的shmid_nattch是一个计数器，所以当使用该共享内存的最后一个进程删除，否则不会真的删除。 四.信号量信号量其实是一个计数器，用来完成多个进程访问共享资源的同步互斥问题。（即让每个进程有条理的访问共享资源，而不会出现混乱访问），其本身并不具有传递数据的功能，出现在这里只是以为了说明使用共享内存访问的一些问题。但是信号量也是临界资源。多个进程可以访问的，所以算是进程间通信的一种，只不过没有其他的 几种方式那么严格罢了。 这里对于一些概念的解释： 临界资源：不同进程访问的同一资源称为临界资源。 临界区：访问访问临界资源的代码 同步：有顺序的取执行 互斥：同一时刻只能有一个进程访问临界区。 因为说信号量本质是一个计数器，所以其伴随着两个原子操作（这种操作中间不会失去时间轮片，瞬间完成的），P操作和V操作。我们给出信号量结构体的伪代码 struct semaphore { int value; poniter_PCB queue; } P操作： p(s) { s.value=s.value--; if(s.value&lt;0) { 该进程的状态设置为等待状态 将该进程的PCB插入信号量结构体的等待队列中s.queue } V操作 p(s) s.value=s.value++; { 唤醒等待的队列s.queue中一个等待的进程 改变其状态为就绪，将其插入就绪队列准备运行 } 操作系统为我们维护了一个信号量集 在/usr/include/linux/sem.h中查看 由此我们可以看到想得到一个信号量集，也需要我们用秘钥key取去获得！ 下面 就来介绍一下关于信号量集和信号量的一些操作函数,如何获得秘钥key这里就不多说了 1.创建一个信号量集 #include &lt;sys/types.h&gt; #include &lt;sys/ipc.h&gt; #include &lt;sys/sem.h&gt; int semget(key_t key, int nsems, int semflg); 参数： 1.key:秘钥 2.信号集中信号量的个数 3.创建信号量集时候的一些参数IPC_CREAT 、IPC_EXCL 2.对于信号量集做的一些操作#include &lt;sys/types.h&gt; #include &lt;sys/ipc.h&gt; #include &lt;sys/sem.h&gt; int semctl(int semid, int semnum, int cmd, ...); 参数： 1.semid:信号量集的标识符 2.semnum:要操作哪个信号量 3.cmd:将要采取的措施。 4…：主要取决去cmd要执行什么动作，这里就需要一个联合体了 因为根据cmd不同的动作，我们都要使用到联合体中的一个成员变量。 当cmd==SETVAL的时候,使用val设置对应的信号量的计数值。 当cmd==GETVAL的时候获取信号量集中对应信号量的计数值 当cmd==IPC_STAT把联合体中semid_ds结构体的值设置为当前信号集的值 当cmd==IPC_SET把当前信号集的值设置为自己定义的semid_ds的值 当cmd==IPC_RMID删除信号集 3.对信号量集的信号量进行操作(PV操作) #include &lt;sys/types.h&gt; #include &lt;sys/ipc.h&gt; #include &lt;sys/sem.h&gt; int semop(int semid, struct sembuf *sops, unsigned nsops); 参数： 1.semid:信号量集的标识符 2.sops:对应一个strutc sembuf* 3.nsops：信号集中信号量的个数 其中struct sembuf的结构是 struct sembuf { short sem_num; short sem_op; short sem_flag; } num:表示信号量的编号 sen_op:取-1，表示p操作–(表示获取信号量控制的资源)，取+1，v操作（表示释放该信号量控制的资源） sem_flag:一般来说取IPC_NOWAIT或者IPC_UNDO。详见unpe458页。 好了关于Linux的进程间通信的一些方法就说完了，当然这里讲的是共享内存，还有一种通信方式是内存映射，即借助同一个文件在不同进程的共享区映射一个区域，当进程在这个区域进程操作 时，相当于在文件中操作，也可以进程通信，这个就需要使用mmap()函数，当然关于这种通信方式也在我的CSDN博客中介绍了。感兴趣的可以了解一下 内存共享和内存映射的区别https://blog.csdn.net/it_iverson/article/details/79303567 还有进程间也可以直接借助文件来进行通信！ 关于本篇博客中进程间通信方式的联系源代码已经上传至github https://github.com/lishuaiwq/linux_ipc 如果博客中有什么不对的地方希望大家提出来！","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"},{"name":"系统编程","slug":"Linux/系统编程","permalink":"http://yoursite.com/categories/Linux/系统编程/"}],"tags":[{"name":"进程间通信","slug":"进程间通信","permalink":"http://yoursite.com/tags/进程间通信/"}]},{"title":"每日五题06","slug":"每日五题06","date":"2018-03-17T01:16:32.000Z","updated":"2018-03-22T12:21:19.483Z","comments":true,"path":"2018/03/17/每日五题06/","link":"","permalink":"http://yoursite.com/2018/03/17/每日五题06/","excerpt":"问题1：fopen,open;fwrite write;fread,read他们的区别和那些的移植性好一些在说这个问题之前，首先补充一点小知识，就是文件描述符和文件指针的区别。（FILE* ,fd） 简单的来说文件描述符就是用linux系统I/O函数open打开文件的时候会返回一个文件描述符，内核会为每一个运行中的进程在进程控制块pcb中维护一个打开文件的记录表，每一个表项都有一个指针指向打开的文件，上边的索引值是记录表的索引值。文件描述符的优点：兼容POSIX标准，许多系统调用都依赖于它；缺点是不能移植到unix之外的系统上去。。","text":"问题1：fopen,open;fwrite write;fread,read他们的区别和那些的移植性好一些在说这个问题之前，首先补充一点小知识，就是文件描述符和文件指针的区别。（FILE* ,fd） 简单的来说文件描述符就是用linux系统I/O函数open打开文件的时候会返回一个文件描述符，内核会为每一个运行中的进程在进程控制块pcb中维护一个打开文件的记录表，每一个表项都有一个指针指向打开的文件，上边的索引值是记录表的索引值。文件描述符的优点：兼容POSIX标准，许多系统调用都依赖于它；缺点是不能移植到unix之外的系统上去。。而FILE*是使用c语言库函数fopen打开文件的时候，返回一个FILE结构的指针，这个结构中主要的内容就是文件描述符和缓冲区。所以说c语言的I/O库函数会维护一个缓冲区，而linux中没有缓冲区，需要我们自己去定义。所以可以说FILE是索引的索引！ 使缓冲区写入磁盘的几种情况： 1.fflush:int fflush(FILE *stream) 2.缓冲区满了，自动写入 3.正常的关闭文件 发fclose,return(main函数中),exit(main函数中) 4.回车键 5.遇到\\n换行结束 下面来一个一个说： 1.fopen和open 上面已经说过了fopen会返回一个FILE类型的指针，而open返回的是文件描述符，并且fopen是c语言的库函数，有缓冲区，open是系统函数，没有缓冲区。并且fopen的可移植性较高，open不可移植。 2.fread和read fread：size_t fread ( void buffer, size_t size, size_t count, FILE stream) buffer：用于接收数据的内存地址（一般情况是自己定义的数组） size：要读的每个数据项的字节数，单位是字节 count：要读count个数据项，每个数据项size个字节 stream：输入流 在这里fwrite也是c库函数，它从文件流中读数据，最多读取count个项，每个项size个字节，如果调用成功返回实际读取到的项个数（小于或等于count），如果不成功或读到文件末尾返回 0。也是库函数，并且有缓冲区，read是linux的系统调用函数，一般来说fread底层也是调用的read，所以fread的效率更高，而且功能比read更强大，read是从文件中读取多少个字节，返回值是读取的字节数。read返回实际读到的字节数，返回0表示已经读到了文件末尾或者没有文件可读，如果出错返回-1并设置错误码。 3.fwrite和write 和fread和read对应着理解这里就不多说了，可移植性肯定是c语言库函数比较好。 问题2：typeid类型检查在c++中，typeid用于返回指针或引用所指对象的实际类型。注意：typeid是操作符，不是函数！ 运行时获知变量类型名称，可以使用 typeid(变量).name()，需要注意不是所有编译器都输出”int”、”float”等之类的名称，对于这类的编译器可以这样使用：float f = 1.1f; if( typeid(f) == typeid(0.0f) ) …… 补充：对非引用类型，typeid是在编译时期识别的，只有引用类型才会在运行时识别。 问题3:模板中的非类型参数与类型参数的区别首先解释一下什么是类型模板参数和非类型模板参数呢？ 我们知道，用模板的时候可以为他提供两种类型的模板形参：一种是类型模板形参，一种是非类型模板形参。例如如下声明： template&lt;class T&gt;void foo(T t); //用的类型模板形参 template&lt;class T,int n&gt;void foo(T t); //用了类型模板形参，同时还用到了非类型模板形参int 两者的区别是：对应类型模板形参，编译器会根据实参（对应模板函数）或者用户指定类型来实例化对应的模板函数或类型。而非类型模板形参主要是用来在模板函数调用时指定该形参的值。非类型模板形参最常用的是用来自动获取数组的维数。 template&lt;class T,int N&gt; void print(T (&amp;r)[N]) { for (int i=0;i&lt;N;++i) { cout&lt;&lt;r[i]&lt;&lt;&quot;,&quot;; } cout&lt;&lt;endl; } 数组的模板形式一般写成这个样子。还有关于非类型的模板参数的一些详解我给出如下博客的链接：http://blog.csdn.net/u012999985/article/details/50780311 问题4:static_cast和reinterpret_cast区别http://blog.csdn.net/deyili/article/details/5354242 问题5：继承中析构函数最好为虚函数，为什么？为什么不建议在构造函数中调用虚函数？1.http://blog.csdn.net/it_iverson/article/details/785316512.http://blog.csdn.net/it_iverson/article/details/78541948","categories":[{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/categories/面试题/"},{"name":"c/c++","slug":"面试题/c-c","permalink":"http://yoursite.com/categories/面试题/c-c/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/面试题/"}]},{"title":"多路I/O转接-poll","slug":"多路I-O转接-poll","date":"2018-03-13T12:35:19.000Z","updated":"2018-03-22T13:46:31.813Z","comments":true,"path":"2018/03/13/多路I-O转接-poll/","link":"","permalink":"http://yoursite.com/2018/03/13/多路I-O转接-poll/","excerpt":"首先多路I/O是在select的基础上进行升级改版的。既然是升级版的那肯定就比select好用。下面我来说说poll相对于select的优点","text":"首先多路I/O是在select的基础上进行升级改版的。既然是升级版的那肯定就比select好用。下面我来说说poll相对于select的优点 1.突破了select受FD_SETSIZE限制只能最多只能监控1024个文件描述符的缺点。我们可以通过修改当前配置文件来改变这个文件数，但是不能超过硬件允许的最大的数量。（我们可以通过cat /proc/sys/fs/file-max这个命令来查看当前硬件允许最大的打开文件的的数量） 可以看到我这里允许最大的数是101015，在用ulimit -a查看一下当前默认的打开数值上限 可以看到上限是1024 现在我们将其修改到4096，vim /etc/security/limits.conf，在文档处添加如下内容然后注销用户或者重启就生效了。 2.select的监听事件和返回事件是一个集合，但是在poll中，它将这两个事件分开了。 3.poll的搜范围变小了，仅限制于我们自己所定义的数组的范围。 但是poll还是有不足的地方，比如我监听了500个文件描述，但是只有3个文件描述符满足动作条件，但是poll还是会遍历整个500个文件描述符，效率有些低，所以我们的理想状态是直接将三个满足条件的文件描述符找出来，这个在epoll中可以做到，我们后面再介绍。 下面来看poll函数： 当然返回值和select是一样的。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"},{"name":"网络编程","slug":"Linux/网络编程","permalink":"http://yoursite.com/categories/Linux/网络编程/"}],"tags":[{"name":"多路I/O转接","slug":"多路I-O转接","permalink":"http://yoursite.com/tags/多路I-O转接/"}]},{"title":"多路I/O转接-select","slug":"多路I-O转接-select","date":"2018-03-10T14:32:04.000Z","updated":"2018-03-22T13:47:00.598Z","comments":true,"path":"2018/03/10/多路I-O转接-select/","link":"","permalink":"http://yoursite.com/2018/03/10/多路I-O转接-select/","excerpt":"为什么会出现多路I/O转接服务器呢？","text":"为什么会出现多路I/O转接服务器呢？因为虽然多线程和多进程服务器可以实现多个客户端同时连接服务器进行数据交流，但是这种实现方式都是进程来监听客户端是否有动静，比如accept,read，如果进程或者线程执行到这些函数的时候没有相关的动作发生则就会发生阻塞等待，函数就不能返回,这样大大的影响了程序的效率。为了解决这个问题，我们提出了一种方法，就是把监听的任务交给内核来帮我们做，当内核发现有相关动作发生以后则给当前进程一个反馈，这个时候进程在进行相关函数的调用去处理这个动作，这样的就不会产生阻塞了。实现这个要求的就是select函数，下面我来详细介。 select() select()，本函数用于确定一个或多个套接口的状态，对每一个套接口，调用者可查询它的可读性、可写性及错误状态信息，用fd_set结构来表示一组等待检查的套接口，在调用返回时，这个结构存有满足一定条件的套接口组的子集，并且select()返回满足条件的套接口的数目。有一组宏可用于对fd_set的操作，这些宏与Berkeley Unix软件中的兼容，但内部的表达是完全不同的。 函数原型和相关参数的解释： int select(int nfds, fd_set *readfds, fd_set *writefds,fd_set *exceptfds, struct timeval *timeout); nfds:监控的文件描述符集里最大文件描述符+1，因为此参数会告诉内核检测前多少个文件描述符的状态 readfds： 监控有读数据到达文件描述符集合，传入传出参数 writefds： 监控写数据到达文件描述符集合，传入传出参数 exceptfds： 监控异常发生达文件描述符集合,如带外数据到达异常，传入传出参数 timeout： 定时阻塞监控时间，3种情况 1.NULL，永远等下去 2.设置timeval，等待固定时间 3.设置timeval里时间均为0，检查描述字后立即返回，轮询 struct timeval { long tv_sec; /* seconds */ long tv_usec; /* microseconds */ }; void FD_CLR(int fd, fd_set *set); //把文件描述符集合里fd清0 int FD_ISSET(int fd, fd_set *set); //测试文件描述符集合里fd是否置1 void FD_SET(int fd, fd_set *set); //把文件描述符集合里fd位置1 void FD_ZERO(fd_set *set); //把文件描述符集合里所有位清0 select有三个可能的返值： 1）返回值－1表示出错。例在未有描述符准备好数据时捕捉到一个信号时 2）返回值0表示没有描述符准备好。若指定的描述符都没有准备好，并且指定的时间已到，则发生这种情况。 3）返回一个正数，说明已经准备好的描述符数，在这种情况下。三个描述符集中仍旧打开的位是已准备好的描述符位。 另外：1.select能监听的文件描述符个数受限于FD_SETSIZE,一般为1024，单纯改变进程打开的文件描述符个数并不能改变select监听文件个数 2.解决1024以下客户端时使用select是很合适的，但如果链接客户端过多，select采用的是轮询模型，会大大降低服务器响应效率，不应在select上投入更多精力。 下面给出select的编程大概思路 1.首先监听int sfd=socket（） 2.然后判断sfd是否有行动，如果有行动则调用int cfd=accept()函数 3.将cfd加入allfd 4.然后判断是否有写入动作，有的话进行写入。 代码已经上传至githubhttps://github.com/lishuaiwq/linux-","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"},{"name":"网络编程","slug":"Linux/网络编程","permalink":"http://yoursite.com/categories/Linux/网络编程/"}],"tags":[{"name":"多路I/O转接","slug":"多路I-O转接","permalink":"http://yoursite.com/tags/多路I-O转接/"}]},{"title":"每日五题05","slug":"每日五题05","date":"2018-03-06T00:52:42.000Z","updated":"2018-03-06T04:24:58.352Z","comments":true,"path":"2018/03/06/每日五题05/","link":"","permalink":"http://yoursite.com/2018/03/06/每日五题05/","excerpt":"问题1：new delete free malloc的关系先简单介绍一下他们。1.new和delete 在c++中使用new和delete动态的创建和释放数组和单个对象。动态创建对象时，只需指定其数据类型，而不必为该对象命名，new表达式返回指向该新创建对象的指针，我们可以通过指针来访问此对象。","text":"问题1：new delete free malloc的关系先简单介绍一下他们。1.new和delete 在c++中使用new和delete动态的创建和释放数组和单个对象。动态创建对象时，只需指定其数据类型，而不必为该对象命名，new表达式返回指向该新创建对象的指针，我们可以通过指针来访问此对象。并且动态创建的对象可以直接初始化： int *p=new int(100);*p=10; int *p=new string(10,&apos;9&apos;);p=&quot;999999999&quot; int *p=int;//未初始化 int *p=int();//初始化为0 int *p=string();//调用默认构造函数 new delete和new []和delete []成对出现！不能混合使用，尽管对于内置类型来说，混合使用不会出错，但是最好不要混合使用。 1.malloc free malloc 向系统申请分配指定size个字节的内存空间，返回类型是 void 类型。void 表示未确定类型的指针。C,C++规定，void* 类型可以强制转换为任何其它类型的指针。 free用来释放malloc在堆上申请的空间。注意：malloc以后要对指针进行转换，free以后要将其置空，还要判断malloc是否成功。 有人在网上说new是在 自由存储区申请的，我觉得这句话可以直接屏蔽，当做没看见！ 下面说说他们的区别:.malloc和new的区别1.new返回指定类型的指针，并且可以自动计算需要的大小，而malloc需要我们自己计算所需空间的大小，并且需要将返回的 void *类型进行指定类型的转换 2.malloc在分配内存的时候只能分配，而不具有初始化的功能，而new具有。 3.malloc和free是标准库函数，而new/delete是C++的运算符，支持重载。malloc和free不支持 4.对于c++自定义类型，new和delete分别会调用对象的构造和析构函数，而这一点malloc/free做不到。 5.对于内置类型而言两者没有太大的区别！ 这里附上一篇博客： http://blog.csdn.net/bat67/article/details/52022105 问题2：子类析构时候要调用父类的析构函数吗？需要：前提子类B继承父类A1.先调用父类的构造函数，然后调用子类的构造函数。准确的说是在子类的构造函数中调用父类的构造函数。先析构子类，再析构父类（B b） 2.用父类指针指向子类对象，如果父类的析构函数不是虚函数的话，则不会释放子类对象，因为不会产生多态，所以因为是父类指针就只调用父类的析构函数。http://blog.csdn.net/it_iverson/article/details/78531651 问题3：描述内存分配及他们的区别1）从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static变量。 2）在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集。 3）从堆上分配，亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由程序员决定，使用非常灵活，但问题也最多。 问题4：分别写出BOOL,int,float,指针类型的变量a与“零”的比较语句1.对于bool型来说和0比较完全可以使用==0或者!=0,但是这种表达形式体现不出来true和false所以应该使用if(a)和if(!a) 2.对于int类型来说就要使用==和!=if(a==0)和if(a!=0) 3.对于float类型来说，不能使用！=和==的符号。因为浮点数是有误差的，它只能规定在这个范围内，所以判断两个浮点数是否相等需要，需要判断他们是否在一个区间内。所以在这里我们定义属于 [-EPSINON,EPSINON] 内得浮点数就可以认为是0，EPSINON是float类型的，只不过使用了typedef而已。 const EXPRESSION EXP = 0.000001 if ( a &lt; EXP&amp;&amp; a &gt;-EXP) 4.对于指针类型if(a==NULL)或者if(a!=NULL) 问题5：数组和指针的区别数组就是数组，指针就是指针。两个数组名除了在sizeof的情况下，都表示数组下标为0的元素的地址！int arr[3];int p=arr;int arr[][3];int p=arr;int **p=arr;这种赋值严格来说是错的，类型不匹配，在C++编译器下是无法通过的。","categories":[{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/categories/面试题/"},{"name":"c/c++","slug":"面试题/c-c","permalink":"http://yoursite.com/categories/面试题/c-c/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/面试题/"}]},{"title":"每日五题04","slug":"每日五题04","date":"2018-03-04T00:59:53.000Z","updated":"2018-03-06T04:25:15.720Z","comments":true,"path":"2018/03/04/每日五题04/","link":"","permalink":"http://yoursite.com/2018/03/04/每日五题04/","excerpt":"问题1：指针和引用的区别1.引用在定义的时候必须被初始化，而指针不用必须被初始化 2.引用初始化以后不能改变其引用对象，指针可以改变 3.不存在指向空值的引用，但是存在指向空值的指针","text":"问题1：指针和引用的区别1.引用在定义的时候必须被初始化，而指针不用必须被初始化 2.引用初始化以后不能改变其引用对象，指针可以改变 3.不存在指向空值的引用，但是存在指向空值的指针4.sizeof引用得到的是所指对象的大小，sizeof指针得到的是指针变量的大小和其指向的内容没有关系 5.指针和引用的自增运算意义不一样 6.引用的创建和销毁不会调用构造和析构函数 7.指针可以有多级，而引用只有一级 8.引用实质也是指针，const int *p=&amp;a，只不过这个工作是编译器帮我们做的 下面附上我关于引用的博客：http://blog.csdn.net/it_iverson/article/details/76832741 问题2：for(;1;)有什么问题？这是一个死循环，for中两个分好中间为判断条件，为真则执行。这里为1，相当于true，也就是死循环。等价于for(;;)也等价于while(1)。 那么下面来说说for(;;)和while(1)的区别 1、 for（；；）死循环里的两个；；代表两个空语句，编译器一般会优化掉它们，直接进入循环体。while（1）死循环里的1被看成表达式，每循环一次都要判断常量1是不是等于零。即，相对来说for式死循环更加高效一点当然以上条件成立还要看编译器的优化，一些编译器优化的两者并无区别，但是，并非所有的编译器都做了这样的优化。 2、for（；；）只有7个字符和while（1）相比省一个字符 问题3：用宏定义写swap(x,y)#define Swap(x,y) (x)=(x)+(y);(y)=(x)-(y);(x)=(x)-(y) #define Swap(x,y) (x)=((x)^(y));(y)=((x)^(y));(x)=((x)^(y)) 问题4：关键字const 和volatilehttp://blog.csdn.net/it_iverson/article/details/78488249这篇博客是关于const的详解下面说说volatile volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。声明时语法：int volatile vInt; 当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存 当一个 变量被const和volatile同时修饰的时候： 主要要搞清楚 编译期 和 运行期的关系。编译期就是 C 编译器将 源代码转化为 汇编再到机器代码 的过程。运行期就是 实际的机器代码在CPU执行 的过程。很多书上说的东西，其实都只是指编译期进行的事情。const 和 volatile 也一样，所谓的 const ，只是告诉编译器要保证在 C的“源代码”里面，没有对该变量进行修改的地方，就是该变量不能而出现在赋值符号左边。实际运行的时候则不是 编译器 所能管的了。同样，volatile的所谓“可能被修改”，是指“在运行期间”可能被修改。也就是告诉编译器，这个变量不是“只”会被这些 C的“源代码”所操纵，其它地方也有操纵它们的地方。所以，C编译器就不能随便对它进行优化了 。所以每次读它要在它内存中读，不要在寄存器中读备份。 问题5：struct和class的区别首先c++中对于struct进行了极大的改进和优化。下面我们来讲讲其和class的区别1.首先是对于默认访问权限的 区别。class如果不写的话就是私有，而struct是public的，c++中的struct也可以继承，实现多态，包含成员函数。所以class和struct可以混合继承，但是这里的继承权限取决于子类是struct还是class ,如果子类是 class 并且没有写继承权限的话就是私有继承，如果是struct并且没有写继承权限的话就是私有继承。 2.class可以用于定义模板参数，而struct不行 3.struct可以默认使用{}初始化，而class不行，因为其默认访问权限是private的,所以将其默认权限改成public的话class也可以使用{}。但是如果给struct加入构造函数，则struct也不能使用{}初始化了。","categories":[{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/categories/面试题/"},{"name":"c/c++","slug":"面试题/c-c","permalink":"http://yoursite.com/categories/面试题/c-c/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/面试题/"}]},{"title":"每日五题03","slug":"每日五题03","date":"2018-03-02T02:37:28.000Z","updated":"2018-03-03T02:50:43.706Z","comments":true,"path":"2018/03/02/每日五题03/","link":"","permalink":"http://yoursite.com/2018/03/02/每日五题03/","excerpt":"问题1：c++中为什么有时候要用extern “C”extern “C’的作用是：告诉C++编译器，我用extern “C”声明的函数，你给我当成C语言中的函数来处理，别走你的c++路线就可以了。为什么要这样呢？举个例子","text":"问题1：c++中为什么有时候要用extern “C”extern “C’的作用是：告诉C++编译器，我用extern “C”声明的函数，你给我当成C语言中的函数来处理，别走你的c++路线就可以了。为什么要这样呢？举个例子a.c文件内容如下： #include&lt;stdio.h&gt; int fun() { return 10; } b.cpp文件内容如下: #include&lt;iostream&gt; using namesapce std; extern int fun();//声明fun函数是外部的 int main() { cout&lt;&lt;fun()&lt;&lt;endl; return 0; } 现在a.c文件的内容我照c编译器取去编译汇编生成二进制文件a.o(gcc -c a.c),下面我们来编译b.cpp文件 g++ b.cpp a.o 我们会发现编译器会报错：错误内容是fun函数未定义，这是为什么呢？明明已经用extern声明了fun函数了还会报错。这就牵扯到了c++和c编译器对于函数的处理c++因为其支持函数重载，所以c++编译器在对函数名处理的过程中需要结合其函数名，参数类型等生成一个独一无二的函数名，而c编译器就只是简单的处理了一下函数名就完了。所以在上面的问题主要是c++编译器将b.cpp中的fun函数可能处理成了_fun_int_（假设）这种类型，而a.c中的函数被c编译器处理成了_fun这种类型，所以在连接的过程中b.cpp在a.c文件中只能找到_fun这个类型函数，和自己文件中的_fun_int_函数无法匹配，所以调用失败，所以显示的未定义。这个时候extern “C”就闪亮登场了。用extern “C”在b.cpp中声明fun函数,像这样 1 extern &quot;C&quot; int fun(); 2 extern &quot;C&quot; { int fun();} 两种形式都可以。那么c++编译器在处理b.cpp的时候就会把fun（）函数按照c语言的命名规则来处理，处理成_fun，这样的话刚好在a.c中找到了_fun，就可以调用成功了！这就是extern “C”的作用！ 强调： 1.gcc -c a.c将a.c生成目标文件等着连接器连接呢会生成a.o g++ b.cpp a.o问题2：全局变量和局部变量的区别 有区别：全局变量保存在内存的全局存储区中，占用静态的存储单元；局部变量保存在栈中，只有在所在函数被调用时才动态地为变量分配存储单元。当一个c程序占用内存以下的几个部分 栈：由编译器进行管理，自动分配和释放，存放函数调用过程中的各种参数、局部变量、返回值以及函数返回地址。操作方式类似数据结构中的栈。 堆：用于程序动态申请分配和释放空间。C语言中的malloc和free，C++中的new和delete均是在堆中进行的。正常情况下，程序员申请的空间在使用结束后应该释放，若程序员没有释放空间，则程序结束时系统自动回收。注意：这里的“堆”并不是数据结构中的“堆”。 全局（静态）存储区:分为DATA段和BSS段。DATA段（全局初始化区）存放初始化的全局变量和静态变量；BSS段（全局未初始化区）存放未初始化的全局变量和静态变量。程序运行结束时自动释放。其中BBS段在程序执行之前会被系统自动清0，所以未初始化的全局变量和静态变量在程序执行之前已经为0。 常量区：存放常量字符串。程序结束后由系统释放。 代码段：存放程序的二进制代码。 问题3:堆栈溢出一般由什么原因造成的1.没有回收垃圾资源 2.递归层次太深 3.分配了超额的空间 问题4：什么函数不能声明为虚函数首先先解释一下什么是虚函数，以及他的作用！然后再回答主问题 1.普通的函数，即不在类中。 因为普通的函数只能被重载，不能被继承，也不能被重写，在编译期间就绑定的函数，所以不能声明为虚函数，没意义。如果你 这样做了 ，编译器会告诉你声明无效！ 2.构造函数 这个我上篇文章中就很详细的说明了这里就不多解释了 3.内联函数 inline函数在编译时被展开，用函数体去替换函数，而virtual是在运行期间才能动态绑定的，这也决定了inline函数不可能为虚函数。（inline函数体现的是一种编译机制，而virtual体现的是一种动态运行机制） 4.静态成员函数 静态成员函数是类的组成部分，但是不是任何对象的组成部分，所有对象共享一份，没有必要动态绑定，也不能被继承【效果能，但机理不能。静态成员函数就一份实体，在父类里；子类继承父类时也无需拷贝父类的静态函数，但子类可以使用父类的静态成员函数】，并且静态成员函数只能访问静态变量。所以不能为virtual。 5.友元函数 友员函数不是类的成员函数，C++不支持友员被继承，所以不能为virtual。 能是虚函数的条件： 1.是类的成员函数； 2.能被继承； 3.动态编译绑定，动态；迟联编译： 注意：空指针不能调用虚函数，因为虚指针在创建对象时创建，没有创建对象就没有虚指针，那么用空指针调用虚函数就会崩溃！！ 空指针可以调用成员函数，前提是该成员函数没有调用类的成员变量，因为指针只要拿到函数的入口地址就可以调用该函数，但是如果调用了成员变量，则因为找不到成员变量而崩溃！！！学习自:http://blog.csdn.net/gogokongyin/article/details/51121974 问题5：全局变量可不可以定义在可被多个.C文件包含的头文件中？为什么？可以！只能用static声明就行！因为用static声明的全局变量就会变成静态全局变量此时他的作用域仅限于定义它的源文件，其他源文件不可见所以不会引起命名冲突和重定义！不然的话全局变量可以在多个源文件中声明，但是只能在一个源文件中定义，不然的话就会引起变量重定义的错误！","categories":[{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/categories/面试题/"},{"name":"c/c++","slug":"面试题/c-c","permalink":"http://yoursite.com/categories/面试题/c-c/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/面试题/"}]},{"title":"每日五题02","slug":"每日五题","date":"2018-03-01T01:20:34.000Z","updated":"2018-03-01T05:07:15.808Z","comments":true,"path":"2018/03/01/每日五题/","link":"","permalink":"http://yoursite.com/2018/03/01/每日五题/","excerpt":"问题1：构造函数能不能是虚函数？为什么？答：构造函数不能是虚函数。解释如下： 1.存储角度：虚函数对应一个虚表，而这个虚表又对应了一个vptr指针，这个指针是在对象的存储空间中的，但是调用虚函数需要用vptr找到虚表中的虚函数来调用，所以对象还没有构造呢 ？构造函数怎么能是虚函数呢？这是矛盾的一点。","text":"问题1：构造函数能不能是虚函数？为什么？答：构造函数不能是虚函数。解释如下： 1.存储角度：虚函数对应一个虚表，而这个虚表又对应了一个vptr指针，这个指针是在对象的存储空间中的，但是调用虚函数需要用vptr找到虚表中的虚函数来调用，所以对象还没有构造呢 ？构造函数怎么能是虚函数呢？这是矛盾的一点。 2.使用角度：虚函数的作用在于通过父类的指针或者引用来调用它的时候能够变成调用子类的那个成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。 3.从实现上看：构造一个对象的时候，必须知道对象的实际类型，而虚函数行为是在运行期间确定实际类型的。而在构造一个对象时，由于对象还未构造成功。编译器无法知道对象 的实际类型，是该类本身，还是该类的一个派生类，或是更深层次的派生类。无法确定。。。 问题2：什么是大小端？如何判断机器的大小端？首先给出大小端的来源： 端模式出自Jonathan Swift书写的《格列佛游记》一书，这本书根据将鸡蛋敲开的方法不同将所有的人分为两类，从圆头开始将鸡蛋敲开的人被归为Big Endian，从尖头开始将鸡蛋敲开的人被归为Littile Endian。小人国的内战就源于吃鸡蛋时是究竟从大头（Big-Endian）敲开还是从小头（Little-Endian）敲开。 在计算机业Big Endian和Little Endian也几乎引起一场战争。在计算机业界，Endian表示数据在存储器中的存放顺序。 大端：高位存在低地址，低位存在高地址； 小端：高位存在高地址，低位存在低地址；（intel的x86，ARM普遍都是属于小端） 你只需要记住：大端：高低，低高。小端：低低高高。大小端在网络字节序中也需要注意这个后面再补充。举个例子：那么怎么判断自己的机器的大小端呢？首先强调一句：CPU对数据的读取是从低地址到高地址的 int is_endian() { union MyUnion { int a; char b; }un; un.a =100;//0x0001不知道放在高端还是低端了， return un.b;//如果返回1的话，证明我们机器是低字节，低地址，即为小端 }//等于1证明为小端，等于0证明为大端 这里就列举一种方法当然还有其他方法，比如说强制类型转换，打印变量地址观察。 问题3：模拟实现strncpy,memcpy,memove1.简单描述strncpy:指定拷贝n个字节，n大于拷贝字节数则多余的补’\\0’,如果n&gt;存储空间，则正常崩溃，n小于拷贝字节，则自己在最后加一个’\\0’. char* my_strncpy(char *dest, char *src, size_t count) { assert(dest&amp;&amp;src); char *p = dest; while (count &amp;&amp; (*dest++ = *src++)) { count--; } if (count &gt; 0)//上述循环出来就意味着&apos;\\0&apos;都复制进去了 { while (--count) *dest++ = &apos;\\0&apos;; } return p; } 2.memcpy拷贝的时候容易覆盖，比图12345，我要把123拷贝到234的位置讲道理拷贝完以后应该是11235，但是用memcpy的话结果就是11115,因为当走到2的时候2已经被1覆盖了，则用1继续覆盖3…，所以我们就需要用memove来拷贝，它 可以实现逆向拷贝即从后往前拷贝,上述例子的拷贝就会是这个样子，把3给4，把2给3，把1给2，这样就不会出现覆盖的问题了即得到我们要的答案，11235 void* my_memcpy(void* dest, void* src, size_t count) { void* ret = dest; char *str1 = (char *)dest; char *str2 = (char *)src; assert(str1&amp;&amp;str2); while (count--) { *str1++ = *str2++; } return ret; } void* my_memove(void* dest, void* src, size_t count) { void* ret = dest; char *str1 = (char *)dest; char *str2 = (char *)src; assert(str1&amp;&amp;str2); if (str1 &gt; str2)//目标位置大于起始位置//使用反向拷贝 { while (count--) { *(str1 + count) = *(str2 + count); } } else { while (count--) { *str1++ = *str2++; } } return ret; } 问题4：“dynamic_cast”和“static _ cast”的区别首先C++提供了两个在层次间转换的关键字那么就是他们两个 首先来说说dynamic_cast： 该运算符把expression转换为type-id类型，但没有运行时类型检查来保证转换的安全性。它主要有如下几种用法： ①用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换。 进行上行转换（把派生类的指针或引用转换成基类表示）是安全的； 进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的。 ②用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性也要开发人员来保证。 ③把空指针转换成目标类型的空指针。 ④把任何类型的表达式转换成void类型。 注意：static_cast不能转换掉expression的const、volatile、或者__unaligned属性。 http://blog.csdn.net/qq_26849233/article/details/62218385 问题5： C++数据类型所表示的值及范围http://blog.csdn.net/a775992553/article/details/8790241","categories":[{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/categories/面试题/"},{"name":"c/c++","slug":"面试题/c-c","permalink":"http://yoursite.com/categories/面试题/c-c/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/面试题/"}]},{"title":"每日五题01","slug":"每日十题","date":"2018-02-28T02:39:09.000Z","updated":"2018-03-06T00:50:21.713Z","comments":true,"path":"2018/02/28/每日十题/","link":"","permalink":"http://yoursite.com/2018/02/28/每日十题/","excerpt":"问题1：写一个不能被继承的类，并且可以正常使用首先一个类不能被继承，则意味着继承这个类的类并没有办法正常工作，比如无法创建对象。所以根据我们对继承的了解，在构造子类对象时先调用基类的构造函数构造子类中基类的部分，所以我们可以在 这里讲父类的构造函数和析构函数设置为私有 ，这样的话，子类就无法正常的创建对象，也就实现了我们的题目所描述的问题了。代码如下：","text":"问题1：写一个不能被继承的类，并且可以正常使用首先一个类不能被继承，则意味着继承这个类的类并没有办法正常工作，比如无法创建对象。所以根据我们对继承的了解，在构造子类对象时先调用基类的构造函数构造子类中基类的部分，所以我们可以在 这里讲父类的构造函数和析构函数设置为私有 ，这样的话，子类就无法正常的创建对象，也就实现了我们的题目所描述的问题了。代码如下： class Base//基类 { private: Base() {}; ~Base(){}; }; Dervice :public Base//派生类 {}; 上面的这个例子中类Base就不能被继承。这样写虽然实现了问题的描述，不过也显得太挫了吧，因为虽然不能被继承，但是同时类Base也无法使用呀，因为其私有的构造函数和析构函数，我们没有办法在类外创建对象。这个时候你可能就会又有一个点子了，在类Base中使用static函数创建一个对象给外界使用不就好了嘛，因为static函数的调用不需要创建对象就可以调用，这样就可以在外界使用类Base了，这确实是个不错的注意。我们来看代码 class Base { private: Base() {}; ~Base(){}; public: static Base* getobj()//生产对象 { Base *p = new Base; return p; } static void delobj(Base *p)//再把对象送进来销毁 { delete p; p = NULL; } }; class Dervice :public Base {}; 这样的话，我们通过对static函数调用（Base s=Base::getobj()）从而实现对类Base的调用，并且如果需要参数的话还可以通过函数将参数传进去。但是这样的话貌似只能在堆上创建对象，而不能在栈上创建对象。可能有人会说你把new 改成 Base s,然后return s不就行了，呵呵。。你可别忘了，Base的析构函数也是私有的，所以在函数退出的地方没法调用私有函数。所以行不通。所以还是不够完美。那么我们接下来该如何优化呢？先给出代码 class Parent { private: ~Parent(){}; Parent(){}; friend class Base; }; class Base : virtual public Parent { public: Base(){}; ~Base(){}; }; class Dervice :public Base { public: Dervice(){}; ~Dervice(){}; }; 我们给通过这种形式就可以使Base可以正常的使用，并且他不能被继承。注意Base一定是虚继承Parent,因为只有根据虚继承的特性，当子类继承了Base以后，创建对象的时候直接去调用Parent的构造对象，从而无法成功。才使Base不能被继承。如果不使用虚继承的话，就会通Base的构造函数去调用，Parent的构造函数，这样是可以的，所以Base就能被继承了在这里需要注意一下！ 问题2：解释一下多态，并且一个多态的例子；说明一个类的默认函数有哪些。1.多态：通俗的说就是同样的调用语句有不同的表现形式。根据实际的对象类型从而决定调用语句的具体的调用目标。C++中对于多态的支持是通过virtual关键字，即使用virtual声明的函数被重写后可以实现多态性。多态只能发生在父类和子类之间。想实现多态有三个固定的条件缺一不可： ①：要有继承，即父类子类这种形式 ②要有虚函数的重写 ③需要父类的指针或者引用 说道多态其实又能牵扯到静态联编和动态联编 联编：就是指一个程序模块代码之间相互关联的一个过程 静态联编：静态联编是指联编工作在编译阶段完成的，这种联编过程是在程序运行之前完成的，又称为早期联编。要实现静态联编，在编译阶段就必须确定程序中的操作调用（如函数调用）与执行该操作代码间的关系，确定这种关系称为束定，在编译时的束定称为静态束定。静态联编对函数的选择是基于指向对象的指针或者引用的类型。其优点是效率高，但灵活性差。（比如重载函数使用静态联编） 动态联编：程序联编推迟到运行时刻进行，所以又成为晚期联编，迟邦定，比如switch和if语句。 不写virtual关键字，编译器实行的是静态联编，不管因为是父类类型所以不管参数类型是什么在编译阶段就确定执行父类的函数了，而动态联编就是在运行时根据不同对象决定调用哪个函数！ 至于多态的实现原理呢？ 1.当类中声明虚函数时，编译器会在类中生成一个虚函数表 2.虚函数表是一个存储类成员函数指针的数据结构 3.虚函数表是由编译器自动生成与维护的 4.virtual成员函数会被编译器放入虚函数表中 5.当存在虚函数时，每个对象中都有一个指向虚函数的指针（C++编译器给父类对象，子类对象提前布局vptr指针），当进行test(parent *base)函数的时候，C++编译器不需要区分子类或者父类对象，只需要再base指针中，找到vptr指针即可） 6.vptr一般作为类对象的第一个成员。 2.类的默认成员函数有：这个是我CSDN博客的详解http://blog.csdn.net/it_iverson/article/details/78511564 问题3：一个指针指向的内容经常变化，如何防止编译器去优化它答：这里考察的是volatitlehttp://blog.csdn.net/turkeyzhou/article/details/8953911 问题4：写一个字符串转浮点型在这个里考察的是atof的模拟实现首先对于算法中强调几点： 1.字符数字-‘\\0’=数字本身，举个例子‘1’的ascii的值为48,‘\\0’的ascii值为47,则48-47=1; 2.对于字符串需要判断是否有+-号 3.需要判断字符串是否有小数点 4.判断空格，是否属于0-9等等一些情况 double my_atof(char *ptr) { int count=0; double sum = 0.0; int flag = 0;//标志位判断是否有+-号,0负数，1正数 while (*ptr) { if (count) count *= 10; if (*ptr == &apos;+&apos;) { ptr++; flag = 1; } else if (*ptr == &apos;-&apos;) ptr++; else if (*ptr == &apos;.&apos;) { ptr++; count++; } else if (*ptr&gt;&apos;0&apos;&amp;&amp;*ptr&lt;&apos;9&apos;) { sum = sum*10 + (*ptr - &apos;0&apos;); ptr++; } else if (*ptr == &apos; &apos;) { ptr++; } else return 0; } sum = sum / count; if (flag == 0) return sum*(-1); else return sum; } 问题5：写一个strcpy函数char* my_strcpy(char *str, char *dest) { assert(str); assert(dest); char *src = str; while (*str++ = *dest++) ; return src; }","categories":[{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/categories/面试题/"},{"name":"c/c++","slug":"面试题/c-c","permalink":"http://yoursite.com/categories/面试题/c-c/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/面试题/"}]},{"title":"深度探索c++对象模型-第四章Function语意学","slug":"深度探索c++对象模型-第四章Function语意学","date":"2018-02-26T12:52:36.000Z","updated":"2018-02-26T14:40:33.735Z","comments":true,"path":"2018/02/26/深度探索c++对象模型-第四章Function语意学/","link":"","permalink":"http://yoursite.com/2018/02/26/深度探索c++对象模型-第四章Function语意学/","excerpt":"此篇文章主要的内容是向我们介绍C++中的一些函数的调用方式，比如成员函数，非常成员函数，静态成员函数，虚函数等等，其中每一种类型的函数的调用方式都不相同。并且除了说明此章节的主题意外还告诉我们了一个小知识点,那就是","text":"此篇文章主要的内容是向我们介绍C++中的一些函数的调用方式，比如成员函数，非常成员函数，静态成员函数，虚函数等等，其中每一种类型的函数的调用方式都不相同。并且除了说明此章节的主题意外还告诉我们了一个小知识点,那就是:①静态成员函数不可能直接存取非静态成员变量，因为它没有this指针，②静态成员函数不可能被声明为const，因为const修饰函数是防止他去修改成员变量的值，而静态成员函数根本不能访问成员，所以修饰它无任何意义，所以规定不能用const 修饰静态成员函数。 1.非静态成员函数作者告诉我们设计非静态成员函数的最起码这个函数需要和一般的非成员函数有同样的效率，假如有如下的两个函数 float magnitude3d(const Point3d *_this){..};//Point3d是类名 float Point3d::magnitude3d() const {..}; 我们看起来是不是成员函数相对来说没有 带来什么负担，反而效率似乎还能高一点，因为非成员函数中还需要经形参取值才能运用成员呢。其实吧，成员函数看着小清新，其实在真正使用的时候，成员函数也是被内化非成员函数的形式了，下面作者就介绍了这个内化的过程！ 1. 改写成员函数的原型，给其安插一个额外的参数到成员函数中，用来提供成员的操作，使得类对象可以将这个函数调用，而这个额外的参数就被称作this指针！代码如下： float Point3d::magnitude3d(Point3d *const this) const {..}; 如果说成员函数是const的，则会变为: float Point3d::magnitude3d(const Point3d *const this) const {..}; 2. 将对成员的存取操作变成这个样子 { this-&gt;_x*this-&gt;y; } 3.将成员函数重新写成一个外部函数（全局函数）。将函数名经过”mangling”处理，使他在程序中独一无二。（这里mangling就是给函数的变量和函数名字经过编译器自己的一些算法，重新起一个独一无二名字，这么做是为了支持C++重载）。致此，函数就内化完成了 extern magnitude_7Point3dFv(register Point3d* const this); 既然函数都被改的飞起来了，那么函数的调用毋庸置疑也被改掉了 Point obj; Point *ptr=&amp;obj; obj.magnitude();------&gt;magnitude_7Point3dFv(&amp;obj) ptr-&gt;magnitude();------&gt;magnitude_7Point3dFv(ptr) 2.虚函数对于虚函数的调用，如果是对象指针调用的话 Point *ptr=&amp;obj; ptr-&gt;normalize();//这个函数是虚函数的话 那么可能会是如下形式： (*(ptr-&gt;vptr[1]))(ptr); 这句话是调用虚函数。，ptr等同于this指针 3.静态成员函数首先先给出两个转换形式， obj.normalize();//静态成员函数调用 normalize_7Point3dSFv(); ptr-&gt;normalize(); normalize_7Point3dSFv(); 会将其转换成非成员函数的调用，即普通的调用。后面即介绍了一下静态成员函数的特点 1.没有this指针，所以不能访问成员变量 2.不能够被声明为volatitle,virtual,const. 3.不需要经过对象就可以调用。 因为其没有this指针的特性，所以其和非成员函数有点类似，所以对其取地址，得到的是非成员函数的指针而非成员函数的指针刑（int (Ponit3d::*)()).….然后此章节后面的内容就是介绍虚拟函数包括其一些对象模型。在这里就不多说了直接附上我的两篇模型剖析的博客，感兴趣的 自己去看看CSDN:http://blog.csdn.net/it_iverson/article/details/78206211自己的博客：http://lishuaii.top/2018/02/26/c++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%89%96%E6%9E%90/#more 后面我在抓抓本章的重点内容写一写吧！嗯…… 然后没发现什么哈哈！！这里在附上一篇inline的详解的博客咯：http://blog.csdn.net/it_iverson/article/details/78473778","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/categories/读书笔记/"},{"name":"深度探索C++对象模型","slug":"读书笔记/深度探索C-对象模型","permalink":"http://yoursite.com/categories/读书笔记/深度探索C-对象模型/"}],"tags":[{"name":"function语意学","slug":"function语意学","permalink":"http://yoursite.com/tags/function语意学/"}]},{"title":"C++对象模型的剖析","slug":"c++对象模型的剖析","date":"2018-02-26T07:11:42.000Z","updated":"2018-02-26T10:08:22.289Z","comments":true,"path":"2018/02/26/c++对象模型的剖析/","link":"","permalink":"http://yoursite.com/2018/02/26/c++对象模型的剖析/","excerpt":"1.单继承对象模型（含有虚函数）首先阐述对象模型：","text":"1.单继承对象模型（含有虚函数）首先阐述对象模型：1.子类和父类都拥有各自的虚函数表 2.如果子类重写了父类的虚函数，则在子类的虚函数表中替换同名的父类虚函数，如果没有重写，则子类的虚函数表中是父类的虚函数（注意在这里只要子类的函数 中有和父类一样的，不管子类加不加vartual，都是重写父类的虚函数） 3.如果子类有自己新写的虚函数，则该虚函数放在虚函数表的后面 class Base { public: int a; public: virtual void fun1() { cout &lt;&lt; &quot;base::fun1()&quot; &lt;&lt; endl; } virtual void fun2() { cout &lt;&lt; &quot;base::fun2()&quot; &lt;&lt; endl; } }; class Dervice :public Base { public: int b; public: virtual void fun2() { cout &lt;&lt; &quot;Dervice::fun2()&quot; &lt;&lt; endl; } virtual void fun3() { cout &lt;&lt; &quot;Dervice::fun3()&quot; &lt;&lt; endl; } }; void test() { Base b; Dervice d; Base *p = &amp;d; b.a = 10; d.b = 20; d.a = 30; } 首先来看base类的对象模型：然后看d的对象模型下面来验证一下 ： typedef void(*fun)(); fun *pp = (fun*)(*(int*)&amp;d); (*pp)(); pp++; (*pp)(); pp++; (*pp)(); 2.简单多继承对象模型简单描述： 1.如果子类新增虚函数，则放在声明的第一个父类的虚函数表中（理解成继承下来的虚表比较好理解）， 2.如果子类重写了父类的虚函数（两个父类中都有的那个虚函数），所有父类虚函数表都要改变。 3.子类内存布局中父类按照其声明顺序排列 class Base1 { public: int base1; public: virtual void fun1() { cout &lt;&lt; &quot;base1::fun1()&quot; &lt;&lt; endl; } }; class Base2 { public: int base2; public: virtual void fun1() { cout &lt;&lt; &quot;base2::fun1()&quot; &lt;&lt; endl; } virtual void fun2() { cout &lt;&lt; &quot;base2::fun2()&quot; &lt;&lt; endl; } }; class Dervice :public Base1,public Base2 { public: int b; public: virtual void fun1() { cout &lt;&lt; &quot;Dervice::fun1()&quot; &lt;&lt; endl; } virtual void fun3() { cout &lt;&lt; &quot;Dervice::fun3()&quot; &lt;&lt; endl; } }; void test() { Base1 b1; Base2 b2; Dervice d; b1.base1 = 10; b2.base2 = 20; d.b = 30; d.base1 = 40; d.base2 = 50; } 验证输出： typedef void(*fun)(); fun *pp = (fun*)(*(int*)&amp;d); (*pp)(); pp++; (*pp)(); pp += 2; /*pp++;*/ (*pp)(); pp++; (*pp)(); 3.简单虚继承对象模型简单阐述： 1.虚继承的子类，如果本身定义了新的虚函数，则编译器为其生成一个新的vptr指针和和虚表，将其新定义的虚函数放进去，并且这个vptr位于对象的最前面 2.虚继承的子类也保留了父类的vptr和虚表 3.虚继承的子类有虚基类表指针vbptr，虚基类表中放的第一个是基类表指针到到对象首地址的偏移地址，后面的则放的是到第二个，第三个虚继承父类的偏移值。 class Base1 { public: int base1; public: virtual void fun1() { cout &lt;&lt; &quot;base1::fun1()&quot; &lt;&lt; endl; } virtual void fun2() { cout &lt;&lt; &quot;base1::fun2()&quot; &lt;&lt; endl; } }; class Dervice :virtual public Base1 { public: int b; public: virtual void fun1() { cout &lt;&lt; &quot;Dervice::fun1()&quot; &lt;&lt; endl; } virtual void fun3() { cout &lt;&lt; &quot;Dervice::fun3()&quot; &lt;&lt; endl; } }; void test() { Base1 b1; Dervice d; b1.base1 = 10; d.b = 20; d.base1 = 30; } 4.菱形继承对象模型菱形继承是多继承和虚继承的复合 class A { public: int _a; virtual void fun1() { cout &lt;&lt; “A::fun1” &lt;&lt; endl; } virtual void fun2() { cout &lt;&lt; “A::fun2” &lt;&lt; endl; } }; class B1 : virtual public A { public: int _b1; virtual void fun1() { cout &lt;&lt; “B1::fun1” &lt;&lt; endl; } virtual void fun3() { cout &lt;&lt; “B1::fun3” &lt;&lt; endl; } }; class B2 :virtual public A { public: int _b2; virtual void fun1() { cout &lt;&lt; &quot;B2::fun1&quot; &lt;&lt; endl; } virtual void fun4() { cout &lt;&lt; &quot;B2::fun4&quot; &lt;&lt; endl; } }; class C :public B1, public B2 { public: int _c; virtual void fun1() { cout &lt;&lt; &quot;C::fun1&quot; &lt;&lt; endl; } virtual void fun3() { cout &lt;&lt; &quot;C::fun3&quot; &lt;&lt; endl; } virtual void fun4() { cout &lt;&lt; &quot;C::fun4&quot; &lt;&lt; endl; } virtual void fun5() { cout &lt;&lt; &quot;C::fun5&quot; &lt;&lt; endl; } };void test() { cout &lt;&lt; &quot;A:&quot; &lt;&lt; sizeof(A) &lt;&lt; endl; cout &lt;&lt; &quot;B1:&quot; &lt;&lt; sizeof(B1) &lt;&lt; endl; cout &lt;&lt; &quot;B2:&quot; &lt;&lt; sizeof(B2) &lt;&lt; endl; cout &lt;&lt; &quot;C:&quot; &lt;&lt; sizeof(C) &lt;&lt; endl; A a; B1 b1; B2 b2; C c; a._a = 10; b1._a = 10; b1._b1 = 20; b2._b2 = 30; b2._a = 10; c._c = 40; c._a = 10; c._b1 = 20; c._b2 = 30; }","categories":[{"name":"c/c++","slug":"c-c","permalink":"http://yoursite.com/categories/c-c/"}],"tags":[{"name":"对象模型剖析","slug":"对象模型剖析","permalink":"http://yoursite.com/tags/对象模型剖析/"}]},{"title":"c陷阱与缺陷","slug":"c陷阱与缺陷","date":"2018-02-25T15:10:39.000Z","updated":"2018-02-26T06:53:49.448Z","comments":true,"path":"2018/02/25/c陷阱与缺陷/","link":"","permalink":"http://yoursite.com/2018/02/25/c陷阱与缺陷/","excerpt":"1.词法陷阱1.注意不要讲=和==混用，还有&amp;和&amp;&amp;是两回事，这个自己都要搞清楚。","text":"1.词法陷阱1.注意不要讲=和==混用，还有&amp;和&amp;&amp;是两回事，这个自己都要搞清楚。 2.词法分析使用的是贪心法，即读取一个字符以后，如果该字符可能组成一个符号，则继续读入下一个 字符，然后判断两个字符组成的字符串是否可以是一个符号的组成部分，如果是则继续读入依此类推。 3.用单引号引起来的一个字符实际上表示一个整数，整数值对应其ascii的值。而双引号引起来的字符串表示的是一个指向无名数组起始字符的指针，该数组被双引号引起来的字符和一个额外的’\\0’初始化 4.用int a=’abc’,则a的值是616263即每个字符对应的ascii的序列，用char a=’abc’，则a的值是c。即c将ab覆盖 5.a+++++b的解释，词法分析的贪心算法可以解得为a ++ ++ + b即((a++)++)+b,但是a++不能当左值，所以这应该是个错误的写法。 2.语法陷阱1. (*(void(*)())0)() 将0转换为函数指针（这个函数指针返回值为void参数为空），然后再调用这个函数.用typedef比较好理解 typedef void (*funcptr)(); (*(funcptr)0)(); 2. (void)(*signal(int,void(*)(int)))(int); signal的参数是整形和函数指针,返回值也是函数指针。用typedef比较好理解 typedef (void ) (*handler)(int); handler signal(int,handler); 3.else总是和同一对括号内最近的未匹配的if相结合。 3.语义陷阱1.如果我们在该使用指针的，确使用了数组名来替换，那么数组名就被当做指向该数组下标为0的元素的指针，所以我们可以这样写 int arr[]={1,2,3}; int *p=arr;//没有任何问题 注意在上述代码中我们并没有写成如下形式 int *p=&amp;arr; 其实这是不合法的操作，因为其类型不匹配，&amp;arr表示整个数组的指针其类型是int[3]*,所以如果你这么写了可能会被视为非法也可能被视为和p=arr一样的操作。 要强调的是：数组名除了在sizeof中以外，其余的所有情形都表示数组下标为0的元素的指针。 （上述问题的背景还限于一维数组，下面我们来讨论一下二维数组） 二维数组其实也是由一维数组组成的，只不过这个一维数组中的每个元素都是一个一维数组。所以如果你这么赋值是不对的 int arr[][3]={1,2,3,4,5,6,7,8,9} int *p=a;错 int **p=a;错 因为a表示数组下标为0的元素的指针，因为其实二维数组，其下标为0的元素也是个数组，所以a的类型就是int (*)[3],类型不兼容的！如果你这么使用了，虽然可能会通过编译，那么将失去了二维数组的意义，就是将二维数组变成了一维数组。我们正确的方式应该是这样的 int (*p)[3]=a; 2.对于指针的复制并不是复制指针的内容，而是使两个指针指向同一块区域，还有就是对字符串常量的修改是非法的！不能对空指针解引用！即使输出空指针的内容也是不合法的！ 3.关于数组越界的无限循环问题 int i, arr[10] = {0}; for (i = 0; i &lt;= 12; i++) { arr[i] = 0; printf(&quot;hello\\n&quot;); } 此代码会无限输出hello,原因如下 4.连接1.连接器：就是想编译汇编产生的若干目标模块，整和成一个被称为载入模块或者可执行程序文件的实体，该实体可以被操作系统直接执行。并且会检查是否有重命名的函数和变量。 2.为了避免发生不必要的麻烦，每个外部变量在所有源文件中只能定义一次。 3.使用static可以防止不同源文件的命名冲突问题，因为它限制了变量的作用域。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/categories/读书笔记/"}],"tags":[{"name":"c陷阱与缺陷","slug":"c陷阱与缺陷","permalink":"http://yoursite.com/tags/c陷阱与缺陷/"}]},{"title":"链表随笔","slug":"链表随笔","date":"2018-02-25T09:29:58.000Z","updated":"2018-02-25T14:18:19.269Z","comments":true,"path":"2018/02/25/链表随笔/","link":"","permalink":"http://yoursite.com/2018/02/25/链表随笔/","excerpt":"此篇文章的主要内容是介绍一些有关链表的核心算法的总结。","text":"此篇文章的主要内容是介绍一些有关链表的核心算法的总结。 1.查找链表倒数第k个结点算法：此算法需要使用快慢指针，举个例子，加入需要查找倒数第3个结点。则指针先走k-1步，然后快慢指针一起走，当快指针指向最后一个结点的 时候，这个时候慢指针则指向我们要查找的倒数第3个结点。代码如下 int K_data(int location)//查找倒数第k个结点 { if (location &gt; 0)//不能小于0 { assert(_head); PNode fast = _head; PNode slow = _head; while (--location) { fast = fast-&gt;_next;// if (fast == NULL) exit(1);//不能超过结点个数 } while (fast-&gt;_next != NULL) { fast = fast-&gt;_next; slow = slow-&gt;_next; } return slow-&gt;_data; } else { exit(0);//直接退出 } } 强调： 1.注意判断查找点是否小于0或大于结点个数，还有结点是否为空 2.使快指针先走k-1步的方法是使用while循环并且使用前置– 3.快慢指针同时走的结束标志是fast-&gt;next！=null，这样就保证了fast刚好走到最后一个结点，如果使用fast!=null的话，则fast就会多走一步，同样慢指针也会多走，算法就会出错！ 2.查找链表中间结点算法：此方法和查找倒数第k个结点的算法思想是一样的，也是使用快慢指针，只不过这个很简单，即快指针走两步，慢指针走一步，这样当快指针到最后一个结点的位置的时候，慢指针则指向中间的结点。 int Find_Middle()//查找中间元素 { PNode fast = _head; PNode slow = _head; while (fast&amp;&amp;fast-&gt;_next) { fast = fast-&gt;_next-&gt;_next; slow = slow-&gt;_next; } return slow-&gt;_data; } 强调： 1.需要对链表进行判空，上述代码没有进行这个操作 2.while循环中的fast和fast-_next的位置步能放反不然就会出错，因为当fast走了两步以后，可能已经为空了，如果你放反了的话，则用空指next，肯定会报错的！ 3.链表逆置算法：逆置链表就是改变结点中的next的指向嘛，所以我们需要定义三个指针，一个指向当前需要逆置的结点的前一个结点，一个指向当前需要逆置的结点，一个指向当前需要逆置结点的后一个结点，然后将当前结点的指针指向前一个结点，然后三个指针同时向前走一步。直到遍历完整个链表注意这里的判断依据是指向需要逆置的结点的这个指针为空的时候则整个链表逆置完成。 void rever()//逆置链表 { if (_head == NULL) return; PNode pre =NULL; PNode next = NULL; PNode cur = _head; while (cur) { next = cur-&gt;_next;//首先让next先走一步 cur-&gt;_next = pre;//改变当前结点的_next pre = cur;//前一个结点走到当前结点 cur = next;//当前结点向前走 } _head = pre; } 强调： 1.注意while循环的指针的指向 2.开始的时候前指针和后指针都是指向空的。 3.最后记得将头指针更新，即最后一个结点变为头指针！ 4.合并两个有序链表合并后的链表也是有序链表算法：选取连个链表中头结点较小的作为头指针，定义一个指向最新的结点的指针，然后作为头指针的链表向后走一步，然后开始判断两个链表谁的结点数小，将其小补在新补的结点后面，然后链表向后走依次比较，直到有一个链表遍历完为止，然后需要判断一下是哪个链表遍历完了，将未遍历完的链表续在其后面。 PNode MergeList(List&lt;T&gt;&amp; s2) { PNode cur1=(*this)._head; PNode cur2 = s2._head; PNode head=NULL; PNode p = NULL; if (cur1 == NULL || cur2 == NULL) return NULL; if (cur1 == cur2) return cur1; if (cur1 != NULL&amp;&amp;cur2 == NULL) return cur1; if (cur2 != NULL&amp;&amp;cur1 == NULL) return cur2; if (cur1-&gt;_data &gt; cur2-&gt;_data)//选较小的作为新链表的头节点 { head = cur2; cur2 = cur2-&gt;_next; } else { head = cur1; cur1 = cur1-&gt;_next; } p = head;//p永远指向最新的结点 while (cur1&amp;&amp;cur2)//如果跳出循环至少有一个为空 { if (cur1-&gt;_data &gt; cur2-&gt;_data)// { p-&gt;_next = cur2; cur2 = cur2-&gt;_next; } else { p-&gt;_next = cur1; cur1 = cur1-&gt;_next; } p = p-&gt;_next; } if (cur1 == NULL) { p-&gt;_next = cur2; } else { p-&gt;_next = cur1; } return head; } 强调： 1.要有指向最新的结点的指针 2.需要对两个链表进行判空操作 5.判断链表是否带坏算法：这个也是需要两个指针，让快指针一次走两步慢指针一次走一步，然后判断快指针是否等于慢指针，等于的话直接返回，证明其带环，因为如果链表带环的话，他们一定会在环上相遇的，如果当fast等于null的时候则说明不带环 PNode JudgeisCircle()//判断链表是否带环 { PNode fast = _head; PNode slow = _head; while (fast&amp;&amp;fast-&gt;_next) { fast = fast-&gt;_next-&gt;_next; slow = slow-&gt;_next; if (fast == slow) return fast;//返回相遇点 } return NULL; } 强调： 1.循环的结束条件是fast&amp;&amp;fast-&gt;_next不等于null，并且顺序不能放反，原理和查找中间结点的理由一样。这样做是为了避免一个结点的时候走两步产生的错误 2.这里返回的是连个结点的相遇点，这个很重要，在求入口点的时候能够用的到 6.求带环链表的交点，即环的入口点算法：这个算法需要用到一点数学思维，先说结果吧即从像雨点到入口点的距离等于从起点到入口点的距离，下面我画图说明吧。下面给出代码： PNode EntrancePoint() { PNode cur = JudgeisCircle();//相遇点 PNode start = _head; while (cur != start) { cur = cur-&gt;_next; start = start-&gt;_next; } return cur; } 强调： 1.一定要将如何推倒这个结论的过程屡清楚 2.循环里面的内容是cur!=start 未完待续….","categories":[{"name":"数据结构随笔","slug":"数据结构随笔","permalink":"http://yoursite.com/categories/数据结构随笔/"}],"tags":[{"name":"链表","slug":"链表","permalink":"http://yoursite.com/tags/链表/"}]},{"title":"static详解","slug":"static详详解","date":"2018-02-25T05:15:28.000Z","updated":"2018-02-25T08:14:11.678Z","comments":true,"path":"2018/02/25/static详详解/","link":"","permalink":"http://yoursite.com/2018/02/25/static详详解/","excerpt":"static关键字是c和c++中都有的，只不过在c语言中它修饰局部变量，全局变量，和函数,在C++中它除了上述的功能外还可以修饰成员变量和成员函数。","text":"static关键字是c和c++中都有的，只不过在c语言中它修饰局部变量，全局变量，和函数,在C++中它除了上述的功能外还可以修饰成员变量和成员函数。 作用： 1.限定作用域 2.保持变量的内容持久化 1.C语言中的static1.修饰全局变量当一个进程的全局变量被static修饰以后，它就可以成为全局静态变量，全局静态变量和其他的全局变量的存储地是一样的，都是在.data段（存放已经初始化了的全局变量）或者.bss段（存放未初始化的全局变量），具体在哪里取决于你有没有初始化这个全局变量。在这里static的作用就是限定作用域了，即被修饰的全局变量只能在定义它的源文件内有效，其他源文件无法访问。 举例如下： .h文件 #include&lt;stdio.h&gt; extern int a;//声明全局变量 void fun();//声明函数 b.c文件 b.c文件 #include&quot;head.h&quot; static int a = 10;//静态全局变量，放在了.data段 void fun() { printf(&quot;%d\\n&quot;, a); } a.c文件 #include&quot;head.h&quot; int main() { printf(&quot;%d&quot;, a); return 0; } 在上述例子中，a.c文件无法使用源文件b.c的被static修饰的全局变量，编译会报错！但是如果在a.c中调用fun函数，在这个函数中使用a就可以，因为其作用域就在其定义的源文件，所以被自己的源文件内的函数访问是没有问题的。 2.修饰局部变量被static修饰的局部变量会被放在.data段，注意这里不是在.bss段，所以这个变量的生命周期在整个程序的生命周期中存在，尽管被放在.data段，但是同样它也只能被自己作用域内的函数或者变量所访问，不能被外界访问。同样static在这里的作用相当于改变了局部变量的生命周期。注意这里解释一下为什么放在了.data段，因为如果用户没有初始化的话，编译器会自动给其赋值0，所以放在了.data段。所以以后每次调用这个变量的时候相当于一直读取同一位置的这个变量，在这里注意和局部变量区别开来。就是因为这一特性，内含静态局部变量的函数是不可重入函数。 b.c文件 #include&quot;head.h&quot; void fun() { static int a; printf(&quot;%d\\n&quot;, a++); } a.c文件 #include&quot;head.h&quot; int main() { fun(); fun(); fun(); getchar(); return 0; } 这样的输出结果是0 1 2. 3.修饰函数这里static的作用也是限定了函数的作用，使被static修饰的函数不能被其他源文件所调用。这里很简单的就不举例子了。static函数可以很好的解决不同源文件中的函数重名的问题，因为每个函数的名字仅自己可见，肯定不会发生冲突的！ 2.C++中的staticC++的中的static关键字主要要讲的就是其修饰的成员变量和成员函数。 1.static修饰成员变量当一个类的成员变量被static关键字修饰以后就变成了静态数据成员了，静态数据成员有一下特点： 1.静态数据成员是类的成员而非对象的成员，它对于所有的对象是共享的，即无论对象被定义了多少个这个静态的成员只有一份，即只分配一次内存，这一样某种程度来说还节省了空间 2.静态成员存储在全局数据区，静态成员在定义的时候要分配空间，所以不不能再类声明的时候定义，需要在类外使用如下形式定义 int myclass::a=0; 3.静态成员同样遵守三个访问限制，同时即使不定义类对象也可以对它进行操作 4.静态成员的作用就是在多个对象拥有同一个属性的时候，使用它可以方便操作，改变一次就全部改变，使用静态数据成员也不存在和其他全局变量的名字冲突，因为其有访问限制属性所以可以实现信息隐藏。 2.static修饰成员函数1.同样静态成员函数也是被所有对象共享，并且他没有this指针，所以他不能访问成员函数和成员变量只能访问静态成员函数和静态成员变量，但是非静态成员函数可以访问静态成员函数和静态变量 2.因为没有this指针，其速度相对于成员函数来说会快一些 3.调用静态成员函数的方式和调用静音胎成员的方式差不多，可以使用.，-&gt;和::","categories":[{"name":"c/c++","slug":"c-c","permalink":"http://yoursite.com/categories/c-c/"}],"tags":[{"name":"static","slug":"static","permalink":"http://yoursite.com/tags/static/"}]},{"title":"堆随笔","slug":"堆随笔","date":"2018-02-24T13:59:15.000Z","updated":"2018-02-24T15:00:39.218Z","comments":true,"path":"2018/02/24/堆随笔/","link":"","permalink":"http://yoursite.com/2018/02/24/堆随笔/","excerpt":"这篇博客的主要内容是对于堆的一些总结","text":"这篇博客的主要内容是对于堆的一些总结 1.创建堆首先堆这个对象的框架你要能够很清楚的记得，即私有成员是vecotr的容器比较好，还有一个就是size用来记录堆中的元素，这样可以用来盛放外界数组的元素，其构造函数主要的作用就是将外界数组元素保存到自己的容器中，然后如果你想创建小堆则用向下调整法，这样堆最开始的创建的就结束了。 2.向下调整法此方法用于建立小堆的时候可以使用，首先数组是根据完全二叉树的方式在数组中存储的，所以我们可以借助树的模型来简化我们的操作，首先需要找到倒数第一个叶子结点的父结点从这里开始调整,这个父结点的位置怎么找呢？举个例子找到父结点的位置以后开始进行调整，首先需要根据父结点在找出其孩子结点的位置，这个很好找就是父结点的位置*2+1就是孩子结点的位置，因为是向下调整发，所以需要判断左右孩子哪个大，找出最小的那个孩子，然后让他和父结点去比较，然后继续向下走继续比较，依此类推。再次我给出代码 // void _Adjustdown(size_t parent) // { // size_t child = parent * 2 + 1;//保存左孩子 // while (child &lt; _size)//在这里的条件给成child&lt;size比较好 // { // Compare s;//定义仿函数对象 // //if (child + 1&lt;_size&amp;&amp;_array[child] &gt;_array[child + 1])//找最小的孩子 // // ++child; // if (child + 1 &lt; _size&amp;&amp;s(_array[child], _array[child + 1]))//找最小的孩子 // ++child; // if (/*child&lt;_size*/s(_array[parent], _array[child])) // { // swap(_array[parent], _array[child]); // parent = child; // child = parent * 2 + 1; // } // else//已经交换好了 // { // break; // } // } // } 在上述代码我想想强调的只有两点： 1.在判断左右孩子的时候当心父结点是单支结点，所以要判断chil+1&lt;size 2.在判断父结点和孩子结点谁小的时候，要当心孩子就结点超出size的大小，需要判断child=0;i–);来循环调整 3.堆的插入操作堆的插入使用的是向上调整法，因为插入之前堆已经建立好了则意味着调整好了，所以插入一个新结点以后意味着，插入的那棵和那棵树的祖先可能会不满足堆的性质，所以只需要顺着那一个方向一直向上调整就可以了，和向下调整法的差别不大，不过这个没有for循环，因为不需要挨个调整呀。给出代码： // void _Adjustup(int child)//向上调整 // { // int parent =(child-1)&gt;&gt;1; // while (parent&gt;=0) // { // if (Compare()(_array[parent], _array[child]))//使用简单的比较器 // { // swap(_array[parent], _array[child]); // child = parent; // parent = (child - 1) &gt;&gt; 1; // } // else // break; // } // } // //}; 在这个算法中我要强调的就是： 1.首先要根据孩子结点找到父结点2.循环的条件是parent&gt;=0 3.堆的pop堆的pop使用的算法有点乾坤大挪移的感觉，将堆顶元素和最后一个元素互换，然后使size–，然后使用向下调整法就解决了，是不是很奇妙 // void Heap_del()//删除堆顶的元素 // { // if (_array.empty()) // return;//空的话直接返回 // int size_last = _size - 1; // swap(_array[0], _array[size_last]); // _array.pop_back();//弹出去 // _size--; // if (_size &gt; 0) // { // _Adjustdown(0); // } // } 重点：1.从头开始调整，但是不需要循环调整！这里就牵扯到了你的向下调整的for循环是写在哪里了。 4.堆排序堆排序的思路也很简单主要是利用堆的性质，如果你要升序排序的话建立大堆，你要降序排序的话建立小堆，然后和删除的思路基本一致，首尾互换然后size– // void Head_Sort() // { // while (_size &gt; 1) // { // swap(_array[0], _array[_size - 1]); // //这里和删除的区别只是不弹出 // --_size; // _Adjustdown(0); // } // } 注意：这里和删除的区别就是不用弹出元素.还有就是break可以直接换成return; 5.优先级队列如何用堆来建立优先级队列呢？首选封装优先级队列的对象里面的成员就是堆，然后只需要使用堆的插入和删除就可以实现优先级队列了。 关于堆的优化就是加入仿函数。","categories":[{"name":"数据结构随笔","slug":"数据结构随笔","permalink":"http://yoursite.com/categories/数据结构随笔/"}],"tags":[{"name":"heap","slug":"heap","permalink":"http://yoursite.com/tags/heap/"}]},{"title":"sizeof详解","slug":"sizeof详解","date":"2018-02-24T07:42:50.000Z","updated":"2018-02-24T13:14:35.584Z","comments":true,"path":"2018/02/24/sizeof详解/","link":"","permalink":"http://yoursite.com/2018/02/24/sizeof详解/","excerpt":"首先对于sizeof做一个简单的介绍让你知道什么是sizoef，从心里对它有个大致的印象。","text":"首先对于sizeof做一个简单的介绍让你知道什么是sizoef，从心里对它有个大致的印象。 定义： sizeof是C/C++中的一个操作符（operator），简单的说其作用就是返回一个对象或者类型所占的内存字节数。 MSDN上的解释为：The sizeof keyword gives the amount of storage, in bytes, associated with a variable or a type(including aggregate types). This keyword returns a value of type size_t. 其返回值类型为size_t，在头文件stddef.h中定义。这是一个依赖于编译系统的值，一般定义为 typedef unsigned int size_t; 好了现在你应该对于sizoef有了一个大概的认识了，现在我们来看看sizoef的基本用法： sizeof(对象）； sizeof(类型）； sizeof 对象；//这个主意和1区分 对于上面的三种用法，其实你只需要掌握sizoef()的这种用法就够了，另外一个自己知道就可以了，因为根本没人去那么用。好了划重点了：记住sizeof计算对象的大小也是转换成对应的类型来计算的，这句话的言外之意就是不同的对象如果类型一样的话，sizoef计算的值是一样的。 用法： 接下来我就所说sizeof的一些应用场景和用法 1 sizeof对一个表达式求值注意：对于表达式求值，编译器会根据表达式结果的类型来计算，一般不会对表达式进行计算 举例如下： int fun(int a) { cout &lt;&lt; &quot;fun::sizoef&quot; &lt;&lt; endl; return a; } void test() { cout &lt;&lt; sizeof(fun(4)); } 此例子的输出就是 4，不会输出fun::sizeof,证明函数没有执行。 2.sizoef的常量性sizeof的计算是放生在编译期间的，所以其可以被当做常量表达式使用 举例如下： int n=10; int arr[sizeof(n)]; 3.sizeof和指针变量注意：当sizoef的对象是指针变量的时候，它的结果和指针所指的内容没有任何的关系，所以在32位计算机中指针变量是4,64位计算机中是8 4.sizeof和数组sizoef的数组的值等于数组所占的内存字节数，这里我在CSDN的博客写的很清楚了，感兴趣的可以自己去看http://blog.csdn.net/it_iverson/article/details/74733426 这里还要强调的一个重点就是数组传参的时候。 void fun(int arr[]) { cout &lt;&lt; sizeof(arr); } void test() { int arr[10] = { 0 }; fun(arr); } 这里的sizoef的输出是4而不是40，因为在函数的形参那里arr已经不是数组类型了，而是蜕变成了指针。相当于int *arr,因为数组是传址传参的，只是把数组首地址传过去了，所以接受地址的自然就是指针变量了，那么正如上文所说，指针变量的大小和其指向的内容没有关系，所以大小为4 5.sizeof和结构体这里主要强调的是结构体内存对其的一些知识在CSDN的博客中也有详细说明 http://blog.csdn.net/it_iverson/article/details/74790127 6.含有位字段的结构体 注意：单独的位字段成员不能被sizeof求值 那么什么是为字段呢？ 位字段是C语言中一种存储结构，不同于一般结构体的是它在定义成员的时候需要指定成员所占的位数。主要应用于嵌入开发 如下： struct stu { char a : 4;//占4位 char b : 3;//占3位 char c : 8;//占8位 };//大小为两个字节 在这里要注意的是： 1.如果相邻的位字段的类型相同，且其位数之和小于自身类型数，则后面的字段和紧挨着前面的字段存储，直到这个不能容纳为止 2.如果相邻的位字段类型相同，且其位数之和大于自身的类型数，则后面的字段从新的存储单元开始。 3.如果相邻位字段类型不同，则根据编译器的不同，是否采取压缩存储就不一定了。 4.如果位字段之间穿插着非为字段，则不进行压缩存储 7.sizeof和联合体因为联合体是重叠式存储，各成员共享一段内存，所以整个联合体的大小就是最大成员所占的空间的大小，假如联合体中有一个结构体成员，那么这个联合体的大小就是这个结构体的大小。","categories":[{"name":"c/c++","slug":"c-c","permalink":"http://yoursite.com/categories/c-c/"}],"tags":[{"name":"sizeof","slug":"sizeof","permalink":"http://yoursite.com/tags/sizeof/"}]}]}