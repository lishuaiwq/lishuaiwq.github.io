{"meta":{"title":"Lishuai's博客","subtitle":null,"description":"承载着太多希望，怎敢轻易辜负","author":"李帅","url":"http://yoursite.com"},"pages":[{"title":"分类","date":"2018-02-24T11:38:30.000Z","updated":"2018-02-24T12:44:22.899Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-02-24T11:37:58.000Z","updated":"2018-02-24T12:45:30.238Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"关于博主","date":"2018-02-24T11:36:41.000Z","updated":"2018-02-24T12:46:34.022Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"博主是一个正在努力进步的小菜，欢迎大家一起来交流学习！"}],"posts":[{"title":"深度探索c++对象模型-第四章Function语意学","slug":"深度探索c++对象模型-第四章Function语意学","date":"2018-02-26T12:52:36.000Z","updated":"2018-02-26T14:40:33.735Z","comments":true,"path":"2018/02/26/深度探索c++对象模型-第四章Function语意学/","link":"","permalink":"http://yoursite.com/2018/02/26/深度探索c++对象模型-第四章Function语意学/","excerpt":"此篇文章主要的内容是向我们介绍C++中的一些函数的调用方式，比如成员函数，非常成员函数，静态成员函数，虚函数等等，其中每一种类型的函数的调用方式都不相同。并且除了说明此章节的主题意外还告诉我们了一个小知识点,那就是","text":"此篇文章主要的内容是向我们介绍C++中的一些函数的调用方式，比如成员函数，非常成员函数，静态成员函数，虚函数等等，其中每一种类型的函数的调用方式都不相同。并且除了说明此章节的主题意外还告诉我们了一个小知识点,那就是:①静态成员函数不可能直接存取非静态成员变量，因为它没有this指针，②静态成员函数不可能被声明为const，因为const修饰函数是防止他去修改成员变量的值，而静态成员函数根本不能访问成员，所以修饰它无任何意义，所以规定不能用const 修饰静态成员函数。 1.非静态成员函数作者告诉我们设计非静态成员函数的最起码这个函数需要和一般的非成员函数有同样的效率，假如有如下的两个函数 float magnitude3d(const Point3d *_this){..};//Point3d是类名 float Point3d::magnitude3d() const {..}; 我们看起来是不是成员函数相对来说没有 带来什么负担，反而效率似乎还能高一点，因为非成员函数中还需要经形参取值才能运用成员呢。其实吧，成员函数看着小清新，其实在真正使用的时候，成员函数也是被内化非成员函数的形式了，下面作者就介绍了这个内化的过程！ 1. 改写成员函数的原型，给其安插一个额外的参数到成员函数中，用来提供成员的操作，使得类对象可以将这个函数调用，而这个额外的参数就被称作this指针！代码如下： float Point3d::magnitude3d(Point3d *const this) const {..}; 如果说成员函数是const的，则会变为: float Point3d::magnitude3d(const Point3d *const this) const {..}; 2. 将对成员的存取操作变成这个样子 { this-&gt;_x*this-&gt;y; } 3.将成员函数重新写成一个外部函数（全局函数）。将函数名经过”mangling”处理，使他在程序中独一无二。（这里mangling就是给函数的变量和函数名字经过编译器自己的一些算法，重新起一个独一无二名字，这么做是为了支持C++重载）。致此，函数就内化完成了 extern magnitude_7Point3dFv(register Point3d* const this); 既然函数都被改的飞起来了，那么函数的调用毋庸置疑也被改掉了 Point obj; Point *ptr=&amp;obj; obj.magnitude();------&gt;magnitude_7Point3dFv(&amp;obj) ptr-&gt;magnitude();------&gt;magnitude_7Point3dFv(ptr) 2.虚函数对于虚函数的调用，如果是对象指针调用的话 Point *ptr=&amp;obj; ptr-&gt;normalize();//这个函数是虚函数的话 那么可能会是如下形式： (*(ptr-&gt;vptr[1]))(ptr); 这句话是调用虚函数。，ptr等同于this指针 3.静态成员函数首先先给出两个转换形式， obj.normalize();//静态成员函数调用 normalize_7Point3dSFv(); ptr-&gt;normalize(); normalize_7Point3dSFv(); 会将其转换成非成员函数的调用，即普通的调用。后面即介绍了一下静态成员函数的特点 1.没有this指针，所以不能访问成员变量 2.不能够被声明为volatitle,virtual,const. 3.不需要经过对象就可以调用。 因为其没有this指针的特性，所以其和非成员函数有点类似，所以对其取地址，得到的是非成员函数的指针而非成员函数的指针刑（int (Ponit3d::*)()).….然后此章节后面的内容就是介绍虚拟函数包括其一些对象模型。在这里就不多说了直接附上我的两篇模型剖析的博客，感兴趣的 自己去看看CSDN:http://blog.csdn.net/it_iverson/article/details/78206211自己的博客：http://lishuaii.top/2018/02/26/c++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%89%96%E6%9E%90/#more 后面我在抓抓本章的重点内容写一写吧！嗯…… 然后没发现什么哈哈！！这里在附上一篇inline的详解的博客咯：http://blog.csdn.net/it_iverson/article/details/78473778","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/categories/读书笔记/"},{"name":"深度探索C++对象模型","slug":"读书笔记/深度探索C-对象模型","permalink":"http://yoursite.com/categories/读书笔记/深度探索C-对象模型/"}],"tags":[{"name":"function语意学","slug":"function语意学","permalink":"http://yoursite.com/tags/function语意学/"}]},{"title":"C++对象模型的剖析","slug":"c++对象模型的剖析","date":"2018-02-26T07:11:42.000Z","updated":"2018-02-26T10:08:22.289Z","comments":true,"path":"2018/02/26/c++对象模型的剖析/","link":"","permalink":"http://yoursite.com/2018/02/26/c++对象模型的剖析/","excerpt":"1.单继承对象模型（含有虚函数）首先阐述对象模型：","text":"1.单继承对象模型（含有虚函数）首先阐述对象模型：1.子类和父类都拥有各自的虚函数表 2.如果子类重写了父类的虚函数，则在子类的虚函数表中替换同名的父类虚函数，如果没有重写，则子类的虚函数表中是父类的虚函数（注意在这里只要子类的函数 中有和父类一样的，不管子类加不加vartual，都是重写父类的虚函数） 3.如果子类有自己新写的虚函数，则该虚函数放在虚函数表的后面 class Base { public: int a; public: virtual void fun1() { cout &lt;&lt; &quot;base::fun1()&quot; &lt;&lt; endl; } virtual void fun2() { cout &lt;&lt; &quot;base::fun2()&quot; &lt;&lt; endl; } }; class Dervice :public Base { public: int b; public: virtual void fun2() { cout &lt;&lt; &quot;Dervice::fun2()&quot; &lt;&lt; endl; } virtual void fun3() { cout &lt;&lt; &quot;Dervice::fun3()&quot; &lt;&lt; endl; } }; void test() { Base b; Dervice d; Base *p = &amp;d; b.a = 10; d.b = 20; d.a = 30; } 首先来看base类的对象模型：然后看d的对象模型下面来验证一下 ： typedef void(*fun)(); fun *pp = (fun*)(*(int*)&amp;d); (*pp)(); pp++; (*pp)(); pp++; (*pp)(); 2.简单多继承对象模型简单描述： 1.如果子类新增虚函数，则放在声明的第一个父类的虚函数表中（理解成继承下来的虚表比较好理解）， 2.如果子类重写了父类的虚函数（两个父类中都有的那个虚函数），所有父类虚函数表都要改变。 3.子类内存布局中父类按照其声明顺序排列 class Base1 { public: int base1; public: virtual void fun1() { cout &lt;&lt; &quot;base1::fun1()&quot; &lt;&lt; endl; } }; class Base2 { public: int base2; public: virtual void fun1() { cout &lt;&lt; &quot;base2::fun1()&quot; &lt;&lt; endl; } virtual void fun2() { cout &lt;&lt; &quot;base2::fun2()&quot; &lt;&lt; endl; } }; class Dervice :public Base1,public Base2 { public: int b; public: virtual void fun1() { cout &lt;&lt; &quot;Dervice::fun1()&quot; &lt;&lt; endl; } virtual void fun3() { cout &lt;&lt; &quot;Dervice::fun3()&quot; &lt;&lt; endl; } }; void test() { Base1 b1; Base2 b2; Dervice d; b1.base1 = 10; b2.base2 = 20; d.b = 30; d.base1 = 40; d.base2 = 50; } 验证输出： typedef void(*fun)(); fun *pp = (fun*)(*(int*)&amp;d); (*pp)(); pp++; (*pp)(); pp += 2; /*pp++;*/ (*pp)(); pp++; (*pp)(); 3.简单虚继承对象模型简单阐述： 1.虚继承的子类，如果本身定义了新的虚函数，则编译器为其生成一个新的vptr指针和和虚表，将其新定义的虚函数放进去，并且这个vptr位于对象的最前面 2.虚继承的子类也保留了父类的vptr和虚表 3.虚继承的子类有虚基类表指针vbptr，虚基类表中放的第一个是基类表指针到到对象首地址的偏移地址，后面的则放的是到第二个，第三个虚继承父类的偏移值。 class Base1 { public: int base1; public: virtual void fun1() { cout &lt;&lt; &quot;base1::fun1()&quot; &lt;&lt; endl; } virtual void fun2() { cout &lt;&lt; &quot;base1::fun2()&quot; &lt;&lt; endl; } }; class Dervice :virtual public Base1 { public: int b; public: virtual void fun1() { cout &lt;&lt; &quot;Dervice::fun1()&quot; &lt;&lt; endl; } virtual void fun3() { cout &lt;&lt; &quot;Dervice::fun3()&quot; &lt;&lt; endl; } }; void test() { Base1 b1; Dervice d; b1.base1 = 10; d.b = 20; d.base1 = 30; } 4.菱形继承对象模型菱形继承是多继承和虚继承的复合 class A { public: int _a; virtual void fun1() { cout &lt;&lt; “A::fun1” &lt;&lt; endl; } virtual void fun2() { cout &lt;&lt; “A::fun2” &lt;&lt; endl; } }; class B1 : virtual public A { public: int _b1; virtual void fun1() { cout &lt;&lt; “B1::fun1” &lt;&lt; endl; } virtual void fun3() { cout &lt;&lt; “B1::fun3” &lt;&lt; endl; } }; class B2 :virtual public A { public: int _b2; virtual void fun1() { cout &lt;&lt; &quot;B2::fun1&quot; &lt;&lt; endl; } virtual void fun4() { cout &lt;&lt; &quot;B2::fun4&quot; &lt;&lt; endl; } }; class C :public B1, public B2 { public: int _c; virtual void fun1() { cout &lt;&lt; &quot;C::fun1&quot; &lt;&lt; endl; } virtual void fun3() { cout &lt;&lt; &quot;C::fun3&quot; &lt;&lt; endl; } virtual void fun4() { cout &lt;&lt; &quot;C::fun4&quot; &lt;&lt; endl; } virtual void fun5() { cout &lt;&lt; &quot;C::fun5&quot; &lt;&lt; endl; } };void test() { cout &lt;&lt; &quot;A:&quot; &lt;&lt; sizeof(A) &lt;&lt; endl; cout &lt;&lt; &quot;B1:&quot; &lt;&lt; sizeof(B1) &lt;&lt; endl; cout &lt;&lt; &quot;B2:&quot; &lt;&lt; sizeof(B2) &lt;&lt; endl; cout &lt;&lt; &quot;C:&quot; &lt;&lt; sizeof(C) &lt;&lt; endl; A a; B1 b1; B2 b2; C c; a._a = 10; b1._a = 10; b1._b1 = 20; b2._b2 = 30; b2._a = 10; c._c = 40; c._a = 10; c._b1 = 20; c._b2 = 30; }","categories":[{"name":"c/c++","slug":"c-c","permalink":"http://yoursite.com/categories/c-c/"}],"tags":[{"name":"对象模型剖析","slug":"对象模型剖析","permalink":"http://yoursite.com/tags/对象模型剖析/"}]},{"title":"c陷阱与缺陷","slug":"c陷阱与缺陷","date":"2018-02-25T15:10:39.000Z","updated":"2018-02-26T06:53:49.448Z","comments":true,"path":"2018/02/25/c陷阱与缺陷/","link":"","permalink":"http://yoursite.com/2018/02/25/c陷阱与缺陷/","excerpt":"1.词法陷阱1.注意不要讲=和==混用，还有&amp;和&amp;&amp;是两回事，这个自己都要搞清楚。","text":"1.词法陷阱1.注意不要讲=和==混用，还有&amp;和&amp;&amp;是两回事，这个自己都要搞清楚。 2.词法分析使用的是贪心法，即读取一个字符以后，如果该字符可能组成一个符号，则继续读入下一个 字符，然后判断两个字符组成的字符串是否可以是一个符号的组成部分，如果是则继续读入依此类推。 3.用单引号引起来的一个字符实际上表示一个整数，整数值对应其ascii的值。而双引号引起来的字符串表示的是一个指向无名数组起始字符的指针，该数组被双引号引起来的字符和一个额外的’\\0’初始化 4.用int a=’abc’,则a的值是616263即每个字符对应的ascii的序列，用char a=’abc’，则a的值是c。即c将ab覆盖 5.a+++++b的解释，词法分析的贪心算法可以解得为a ++ ++ + b即((a++)++)+b,但是a++不能当左值，所以这应该是个错误的写法。 2.语法陷阱1. (*(void(*)())0)() 将0转换为函数指针（这个函数指针返回值为void参数为空），然后再调用这个函数.用typedef比较好理解 typedef void (*funcptr)(); (*(funcptr)0)(); 2. (void)(*signal(int,void(*)(int)))(int); signal的参数是整形和函数指针,返回值也是函数指针。用typedef比较好理解 typedef (void ) (*handler)(int); handler signal(int,handler); 3.else总是和同一对括号内最近的未匹配的if相结合。 3.语义陷阱1.如果我们在该使用指针的，确使用了数组名来替换，那么数组名就被当做指向该数组下标为0的元素的指针，所以我们可以这样写 int arr[]={1,2,3}; int *p=arr;//没有任何问题 注意在上述代码中我们并没有写成如下形式 int *p=&amp;arr; 其实这是不合法的操作，因为其类型不匹配，&amp;arr表示整个数组的指针其类型是int[3]*,所以如果你这么写了可能会被视为非法也可能被视为和p=arr一样的操作。 要强调的是：数组名除了在sizeof中以外，其余的所有情形都表示数组下标为0的元素的指针。 （上述问题的背景还限于一维数组，下面我们来讨论一下二维数组） 二维数组其实也是由一维数组组成的，只不过这个一维数组中的每个元素都是一个一维数组。所以如果你这么赋值是不对的 int arr[][3]={1,2,3,4,5,6,7,8,9} int *p=a;错 int **p=a;错 因为a表示数组下标为0的元素的指针，因为其实二维数组，其下标为0的元素也是个数组，所以a的类型就是int (*)[3],类型不兼容的！如果你这么使用了，虽然可能会通过编译，那么将失去了二维数组的意义，就是将二维数组变成了一维数组。我们正确的方式应该是这样的 int (*p)[3]=a; 2.对于指针的复制并不是复制指针的内容，而是使两个指针指向同一块区域，还有就是对字符串常量的修改是非法的！不能对空指针解引用！即使输出空指针的内容也是不合法的！ 3.关于数组越界的无限循环问题 int i, arr[10] = {0}; for (i = 0; i &lt;= 12; i++) { arr[i] = 0; printf(&quot;hello\\n&quot;); } 此代码会无限输出hello,原因如下 4.连接1.连接器：就是想编译汇编产生的若干目标模块，整和成一个被称为载入模块或者可执行程序文件的实体，该实体可以被操作系统直接执行。并且会检查是否有重命名的函数和变量。 2.为了避免发生不必要的麻烦，每个外部变量在所有源文件中只能定义一次。 3.使用static可以防止不同源文件的命名冲突问题，因为它限制了变量的作用域。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/categories/读书笔记/"}],"tags":[{"name":"c陷阱与缺陷","slug":"c陷阱与缺陷","permalink":"http://yoursite.com/tags/c陷阱与缺陷/"}]},{"title":"链表随笔","slug":"链表随笔","date":"2018-02-25T09:29:58.000Z","updated":"2018-02-25T14:18:19.269Z","comments":true,"path":"2018/02/25/链表随笔/","link":"","permalink":"http://yoursite.com/2018/02/25/链表随笔/","excerpt":"此篇文章的主要内容是介绍一些有关链表的核心算法的总结。","text":"此篇文章的主要内容是介绍一些有关链表的核心算法的总结。 1.查找链表倒数第k个结点算法：此算法需要使用快慢指针，举个例子，加入需要查找倒数第3个结点。则指针先走k-1步，然后快慢指针一起走，当快指针指向最后一个结点的 时候，这个时候慢指针则指向我们要查找的倒数第3个结点。代码如下 int K_data(int location)//查找倒数第k个结点 { if (location &gt; 0)//不能小于0 { assert(_head); PNode fast = _head; PNode slow = _head; while (--location) { fast = fast-&gt;_next;// if (fast == NULL) exit(1);//不能超过结点个数 } while (fast-&gt;_next != NULL) { fast = fast-&gt;_next; slow = slow-&gt;_next; } return slow-&gt;_data; } else { exit(0);//直接退出 } } 强调： 1.注意判断查找点是否小于0或大于结点个数，还有结点是否为空 2.使快指针先走k-1步的方法是使用while循环并且使用前置– 3.快慢指针同时走的结束标志是fast-&gt;next！=null，这样就保证了fast刚好走到最后一个结点，如果使用fast!=null的话，则fast就会多走一步，同样慢指针也会多走，算法就会出错！ 2.查找链表中间结点算法：此方法和查找倒数第k个结点的算法思想是一样的，也是使用快慢指针，只不过这个很简单，即快指针走两步，慢指针走一步，这样当快指针到最后一个结点的位置的时候，慢指针则指向中间的结点。 int Find_Middle()//查找中间元素 { PNode fast = _head; PNode slow = _head; while (fast&amp;&amp;fast-&gt;_next) { fast = fast-&gt;_next-&gt;_next; slow = slow-&gt;_next; } return slow-&gt;_data; } 强调： 1.需要对链表进行判空，上述代码没有进行这个操作 2.while循环中的fast和fast-_next的位置步能放反不然就会出错，因为当fast走了两步以后，可能已经为空了，如果你放反了的话，则用空指next，肯定会报错的！ 3.链表逆置算法：逆置链表就是改变结点中的next的指向嘛，所以我们需要定义三个指针，一个指向当前需要逆置的结点的前一个结点，一个指向当前需要逆置的结点，一个指向当前需要逆置结点的后一个结点，然后将当前结点的指针指向前一个结点，然后三个指针同时向前走一步。直到遍历完整个链表注意这里的判断依据是指向需要逆置的结点的这个指针为空的时候则整个链表逆置完成。 void rever()//逆置链表 { if (_head == NULL) return; PNode pre =NULL; PNode next = NULL; PNode cur = _head; while (cur) { next = cur-&gt;_next;//首先让next先走一步 cur-&gt;_next = pre;//改变当前结点的_next pre = cur;//前一个结点走到当前结点 cur = next;//当前结点向前走 } _head = pre; } 强调： 1.注意while循环的指针的指向 2.开始的时候前指针和后指针都是指向空的。 3.最后记得将头指针更新，即最后一个结点变为头指针！ 4.合并两个有序链表合并后的链表也是有序链表算法：选取连个链表中头结点较小的作为头指针，定义一个指向最新的结点的指针，然后作为头指针的链表向后走一步，然后开始判断两个链表谁的结点数小，将其小补在新补的结点后面，然后链表向后走依次比较，直到有一个链表遍历完为止，然后需要判断一下是哪个链表遍历完了，将未遍历完的链表续在其后面。 PNode MergeList(List&lt;T&gt;&amp; s2) { PNode cur1=(*this)._head; PNode cur2 = s2._head; PNode head=NULL; PNode p = NULL; if (cur1 == NULL || cur2 == NULL) return NULL; if (cur1 == cur2) return cur1; if (cur1 != NULL&amp;&amp;cur2 == NULL) return cur1; if (cur2 != NULL&amp;&amp;cur1 == NULL) return cur2; if (cur1-&gt;_data &gt; cur2-&gt;_data)//选较小的作为新链表的头节点 { head = cur2; cur2 = cur2-&gt;_next; } else { head = cur1; cur1 = cur1-&gt;_next; } p = head;//p永远指向最新的结点 while (cur1&amp;&amp;cur2)//如果跳出循环至少有一个为空 { if (cur1-&gt;_data &gt; cur2-&gt;_data)// { p-&gt;_next = cur2; cur2 = cur2-&gt;_next; } else { p-&gt;_next = cur1; cur1 = cur1-&gt;_next; } p = p-&gt;_next; } if (cur1 == NULL) { p-&gt;_next = cur2; } else { p-&gt;_next = cur1; } return head; } 强调： 1.要有指向最新的结点的指针 2.需要对两个链表进行判空操作 5.判断链表是否带坏算法：这个也是需要两个指针，让快指针一次走两步慢指针一次走一步，然后判断快指针是否等于慢指针，等于的话直接返回，证明其带环，因为如果链表带环的话，他们一定会在环上相遇的，如果当fast等于null的时候则说明不带环 PNode JudgeisCircle()//判断链表是否带环 { PNode fast = _head; PNode slow = _head; while (fast&amp;&amp;fast-&gt;_next) { fast = fast-&gt;_next-&gt;_next; slow = slow-&gt;_next; if (fast == slow) return fast;//返回相遇点 } return NULL; } 强调： 1.循环的结束条件是fast&amp;&amp;fast-&gt;_next不等于null，并且顺序不能放反，原理和查找中间结点的理由一样。这样做是为了避免一个结点的时候走两步产生的错误 2.这里返回的是连个结点的相遇点，这个很重要，在求入口点的时候能够用的到 6.求带环链表的交点，即环的入口点算法：这个算法需要用到一点数学思维，先说结果吧即从像雨点到入口点的距离等于从起点到入口点的距离，下面我画图说明吧。下面给出代码： PNode EntrancePoint() { PNode cur = JudgeisCircle();//相遇点 PNode start = _head; while (cur != start) { cur = cur-&gt;_next; start = start-&gt;_next; } return cur; } 强调： 1.一定要将如何推倒这个结论的过程屡清楚 2.循环里面的内容是cur!=start 未完待续….","categories":[{"name":"数据结构随笔","slug":"数据结构随笔","permalink":"http://yoursite.com/categories/数据结构随笔/"}],"tags":[{"name":"链表","slug":"链表","permalink":"http://yoursite.com/tags/链表/"}]},{"title":"static详解","slug":"static详详解","date":"2018-02-25T05:15:28.000Z","updated":"2018-02-25T08:14:11.678Z","comments":true,"path":"2018/02/25/static详详解/","link":"","permalink":"http://yoursite.com/2018/02/25/static详详解/","excerpt":"static关键字是c和c++中都有的，只不过在c语言中它修饰局部变量，全局变量，和函数,在C++中它除了上述的功能外还可以修饰成员变量和成员函数。","text":"static关键字是c和c++中都有的，只不过在c语言中它修饰局部变量，全局变量，和函数,在C++中它除了上述的功能外还可以修饰成员变量和成员函数。 作用： 1.限定作用域 2.保持变量的内容持久化 1.C语言中的static1.修饰全局变量当一个进程的全局变量被static修饰以后，它就可以成为全局静态变量，全局静态变量和其他的全局变量的存储地是一样的，都是在.data段（存放已经初始化了的全局变量）或者.bss段（存放未初始化的全局变量），具体在哪里取决于你有没有初始化这个全局变量。在这里static的作用就是限定作用域了，即被修饰的全局变量只能在定义它的源文件内有效，其他源文件无法访问。 举例如下： .h文件 #include&lt;stdio.h&gt; extern int a;//声明全局变量 void fun();//声明函数 b.c文件 b.c文件 #include&quot;head.h&quot; static int a = 10;//静态全局变量，放在了.data段 void fun() { printf(&quot;%d\\n&quot;, a); } a.c文件 #include&quot;head.h&quot; int main() { printf(&quot;%d&quot;, a); return 0; } 在上述例子中，a.c文件无法使用源文件b.c的被static修饰的全局变量，编译会报错！但是如果在a.c中调用fun函数，在这个函数中使用a就可以，因为其作用域就在其定义的源文件，所以被自己的源文件内的函数访问是没有问题的。 2.修饰局部变量被static修饰的局部变量会被放在.data段，注意这里不是在.bss段，所以这个变量的生命周期在整个程序的生命周期中存在，尽管被放在.data段，但是同样它也只能被自己作用域内的函数或者变量所访问，不能被外界访问。同样static在这里的作用相当于改变了局部变量的生命周期。注意这里解释一下为什么放在了.data段，因为如果用户没有初始化的话，编译器会自动给其赋值0，所以放在了.data段。所以以后每次调用这个变量的时候相当于一直读取同一位置的这个变量，在这里注意和局部变量区别开来。就是因为这一特性，内含静态局部变量的函数是不可重入函数。 b.c文件 #include&quot;head.h&quot; void fun() { static int a; printf(&quot;%d\\n&quot;, a++); } a.c文件 #include&quot;head.h&quot; int main() { fun(); fun(); fun(); getchar(); return 0; } 这样的输出结果是0 1 2. 3.修饰函数这里static的作用也是限定了函数的作用，使被static修饰的函数不能被其他源文件所调用。这里很简单的就不举例子了。static函数可以很好的解决不同源文件中的函数重名的问题，因为每个函数的名字仅自己可见，肯定不会发生冲突的！ 2.C++中的staticC++的中的static关键字主要要讲的就是其修饰的成员变量和成员函数。 1.static修饰成员变量当一个类的成员变量被static关键字修饰以后就变成了静态数据成员了，静态数据成员有一下特点： 1.静态数据成员是类的成员而非对象的成员，它对于所有的对象是共享的，即无论对象被定义了多少个这个静态的成员只有一份，即只分配一次内存，这一样某种程度来说还节省了空间 2.静态成员存储在全局数据区，静态成员在定义的时候要分配空间，所以不不能再类声明的时候定义，需要在类外使用如下形式定义 int myclass::a=0; 3.静态成员同样遵守三个访问限制，同时即使不定义类对象也可以对它进行操作 4.静态成员的作用就是在多个对象拥有同一个属性的时候，使用它可以方便操作，改变一次就全部改变，使用静态数据成员也不存在和其他全局变量的名字冲突，因为其有访问限制属性所以可以实现信息隐藏。 2.static修饰成员函数1.同样静态成员函数也是被所有对象共享，并且他没有this指针，所以他不能访问成员函数和成员变量只能访问静态成员函数和静态成员变量，但是非静态成员函数可以访问静态成员函数和静态变量 2.因为没有this指针，其速度相对于成员函数来说会快一些 3.调用静态成员函数的方式和调用静音胎成员的方式差不多，可以使用.，-&gt;和::","categories":[{"name":"c/c++","slug":"c-c","permalink":"http://yoursite.com/categories/c-c/"}],"tags":[{"name":"static","slug":"static","permalink":"http://yoursite.com/tags/static/"}]},{"title":"堆随笔","slug":"堆随笔","date":"2018-02-24T13:59:15.000Z","updated":"2018-02-24T15:00:39.218Z","comments":true,"path":"2018/02/24/堆随笔/","link":"","permalink":"http://yoursite.com/2018/02/24/堆随笔/","excerpt":"这篇博客的主要内容是对于堆的一些总结","text":"这篇博客的主要内容是对于堆的一些总结 1.创建堆首先堆这个对象的框架你要能够很清楚的记得，即私有成员是vecotr的容器比较好，还有一个就是size用来记录堆中的元素，这样可以用来盛放外界数组的元素，其构造函数主要的作用就是将外界数组元素保存到自己的容器中，然后如果你想创建小堆则用向下调整法，这样堆最开始的创建的就结束了。 2.向下调整法此方法用于建立小堆的时候可以使用，首先数组是根据完全二叉树的方式在数组中存储的，所以我们可以借助树的模型来简化我们的操作，首先需要找到倒数第一个叶子结点的父结点从这里开始调整,这个父结点的位置怎么找呢？举个例子找到父结点的位置以后开始进行调整，首先需要根据父结点在找出其孩子结点的位置，这个很好找就是父结点的位置*2+1就是孩子结点的位置，因为是向下调整发，所以需要判断左右孩子哪个大，找出最小的那个孩子，然后让他和父结点去比较，然后继续向下走继续比较，依此类推。再次我给出代码 // void _Adjustdown(size_t parent) // { // size_t child = parent * 2 + 1;//保存左孩子 // while (child &lt; _size)//在这里的条件给成child&lt;size比较好 // { // Compare s;//定义仿函数对象 // //if (child + 1&lt;_size&amp;&amp;_array[child] &gt;_array[child + 1])//找最小的孩子 // // ++child; // if (child + 1 &lt; _size&amp;&amp;s(_array[child], _array[child + 1]))//找最小的孩子 // ++child; // if (/*child&lt;_size*/s(_array[parent], _array[child])) // { // swap(_array[parent], _array[child]); // parent = child; // child = parent * 2 + 1; // } // else//已经交换好了 // { // break; // } // } // } 在上述代码我想想强调的只有两点： 1.在判断左右孩子的时候当心父结点是单支结点，所以要判断chil+1&lt;size 2.在判断父结点和孩子结点谁小的时候，要当心孩子就结点超出size的大小，需要判断child=0;i–);来循环调整 3.堆的插入操作堆的插入使用的是向上调整法，因为插入之前堆已经建立好了则意味着调整好了，所以插入一个新结点以后意味着，插入的那棵和那棵树的祖先可能会不满足堆的性质，所以只需要顺着那一个方向一直向上调整就可以了，和向下调整法的差别不大，不过这个没有for循环，因为不需要挨个调整呀。给出代码： // void _Adjustup(int child)//向上调整 // { // int parent =(child-1)&gt;&gt;1; // while (parent&gt;=0) // { // if (Compare()(_array[parent], _array[child]))//使用简单的比较器 // { // swap(_array[parent], _array[child]); // child = parent; // parent = (child - 1) &gt;&gt; 1; // } // else // break; // } // } // //}; 在这个算法中我要强调的就是： 1.首先要根据孩子结点找到父结点2.循环的条件是parent&gt;=0 3.堆的pop堆的pop使用的算法有点乾坤大挪移的感觉，将堆顶元素和最后一个元素互换，然后使size–，然后使用向下调整法就解决了，是不是很奇妙 // void Heap_del()//删除堆顶的元素 // { // if (_array.empty()) // return;//空的话直接返回 // int size_last = _size - 1; // swap(_array[0], _array[size_last]); // _array.pop_back();//弹出去 // _size--; // if (_size &gt; 0) // { // _Adjustdown(0); // } // } 重点：1.从头开始调整，但是不需要循环调整！这里就牵扯到了你的向下调整的for循环是写在哪里了。 4.堆排序堆排序的思路也很简单主要是利用堆的性质，如果你要升序排序的话建立大堆，你要降序排序的话建立小堆，然后和删除的思路基本一致，首尾互换然后size– // void Head_Sort() // { // while (_size &gt; 1) // { // swap(_array[0], _array[_size - 1]); // //这里和删除的区别只是不弹出 // --_size; // _Adjustdown(0); // } // } 注意：这里和删除的区别就是不用弹出元素.还有就是break可以直接换成return; 5.优先级队列如何用堆来建立优先级队列呢？首选封装优先级队列的对象里面的成员就是堆，然后只需要使用堆的插入和删除就可以实现优先级队列了。 关于堆的优化就是加入仿函数。","categories":[{"name":"数据结构随笔","slug":"数据结构随笔","permalink":"http://yoursite.com/categories/数据结构随笔/"}],"tags":[{"name":"heap","slug":"heap","permalink":"http://yoursite.com/tags/heap/"}]},{"title":"sizeof详解","slug":"sizeof详解","date":"2018-02-24T07:42:50.000Z","updated":"2018-02-24T13:14:35.584Z","comments":true,"path":"2018/02/24/sizeof详解/","link":"","permalink":"http://yoursite.com/2018/02/24/sizeof详解/","excerpt":"首先对于sizeof做一个简单的介绍让你知道什么是sizoef，从心里对它有个大致的印象。","text":"首先对于sizeof做一个简单的介绍让你知道什么是sizoef，从心里对它有个大致的印象。 定义： sizeof是C/C++中的一个操作符（operator），简单的说其作用就是返回一个对象或者类型所占的内存字节数。 MSDN上的解释为：The sizeof keyword gives the amount of storage, in bytes, associated with a variable or a type(including aggregate types). This keyword returns a value of type size_t. 其返回值类型为size_t，在头文件stddef.h中定义。这是一个依赖于编译系统的值，一般定义为 typedef unsigned int size_t; 好了现在你应该对于sizoef有了一个大概的认识了，现在我们来看看sizoef的基本用法： sizeof(对象）； sizeof(类型）； sizeof 对象；//这个主意和1区分 对于上面的三种用法，其实你只需要掌握sizoef()的这种用法就够了，另外一个自己知道就可以了，因为根本没人去那么用。好了划重点了：记住sizeof计算对象的大小也是转换成对应的类型来计算的，这句话的言外之意就是不同的对象如果类型一样的话，sizoef计算的值是一样的。 用法： 接下来我就所说sizeof的一些应用场景和用法 1 sizeof对一个表达式求值注意：对于表达式求值，编译器会根据表达式结果的类型来计算，一般不会对表达式进行计算 举例如下： int fun(int a) { cout &lt;&lt; &quot;fun::sizoef&quot; &lt;&lt; endl; return a; } void test() { cout &lt;&lt; sizeof(fun(4)); } 此例子的输出就是 4，不会输出fun::sizeof,证明函数没有执行。 2.sizoef的常量性sizeof的计算是放生在编译期间的，所以其可以被当做常量表达式使用 举例如下： int n=10; int arr[sizeof(n)]; 3.sizeof和指针变量注意：当sizoef的对象是指针变量的时候，它的结果和指针所指的内容没有任何的关系，所以在32位计算机中指针变量是4,64位计算机中是8 4.sizeof和数组sizoef的数组的值等于数组所占的内存字节数，这里我在CSDN的博客写的很清楚了，感兴趣的可以自己去看http://blog.csdn.net/it_iverson/article/details/74733426 这里还要强调的一个重点就是数组传参的时候。 void fun(int arr[]) { cout &lt;&lt; sizeof(arr); } void test() { int arr[10] = { 0 }; fun(arr); } 这里的sizoef的输出是4而不是40，因为在函数的形参那里arr已经不是数组类型了，而是蜕变成了指针。相当于int *arr,因为数组是传址传参的，只是把数组首地址传过去了，所以接受地址的自然就是指针变量了，那么正如上文所说，指针变量的大小和其指向的内容没有关系，所以大小为4 5.sizeof和结构体这里主要强调的是结构体内存对其的一些知识在CSDN的博客中也有详细说明 http://blog.csdn.net/it_iverson/article/details/74790127 6.含有位字段的结构体 注意：单独的位字段成员不能被sizeof求值 那么什么是为字段呢？ 位字段是C语言中一种存储结构，不同于一般结构体的是它在定义成员的时候需要指定成员所占的位数。主要应用于嵌入开发 如下： struct stu { char a : 4;//占4位 char b : 3;//占3位 char c : 8;//占8位 };//大小为两个字节 在这里要注意的是： 1.如果相邻的位字段的类型相同，且其位数之和小于自身类型数，则后面的字段和紧挨着前面的字段存储，直到这个不能容纳为止 2.如果相邻的位字段类型相同，且其位数之和大于自身的类型数，则后面的字段从新的存储单元开始。 3.如果相邻位字段类型不同，则根据编译器的不同，是否采取压缩存储就不一定了。 4.如果位字段之间穿插着非为字段，则不进行压缩存储 7.sizeof和联合体因为联合体是重叠式存储，各成员共享一段内存，所以整个联合体的大小就是最大成员所占的空间的大小，假如联合体中有一个结构体成员，那么这个联合体的大小就是这个结构体的大小。","categories":[{"name":"c/c++","slug":"c-c","permalink":"http://yoursite.com/categories/c-c/"}],"tags":[{"name":"sizeof","slug":"sizeof","permalink":"http://yoursite.com/tags/sizeof/"}]}]}