{"meta":{"title":"Lishuai's博客","subtitle":null,"description":"承载着太多希望，怎敢轻易辜负","author":"李帅","url":"http://yoursite.com"},"pages":[{"title":"关于博主","date":"2018-02-24T11:36:41.000Z","updated":"2018-02-24T12:46:34.022Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"博主是一个正在努力进步的小菜，欢迎大家一起来交流学习！"},{"title":"分类","date":"2018-02-24T11:38:30.000Z","updated":"2018-02-24T12:44:22.899Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-02-24T11:37:58.000Z","updated":"2018-02-24T12:45:30.238Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"static详解","slug":"static详详解","date":"2018-02-25T05:15:28.000Z","updated":"2018-02-25T08:14:11.678Z","comments":true,"path":"2018/02/25/static详详解/","link":"","permalink":"http://yoursite.com/2018/02/25/static详详解/","excerpt":"static关键字是c和c++中都有的，只不过在c语言中它修饰局部变量，全局变量，和函数,在C++中它除了上述的功能外还可以修饰成员变量和成员函数。","text":"static关键字是c和c++中都有的，只不过在c语言中它修饰局部变量，全局变量，和函数,在C++中它除了上述的功能外还可以修饰成员变量和成员函数。 作用： 1.限定作用域 2.保持变量的内容持久化 1.C语言中的static1.修饰全局变量当一个进程的全局变量被static修饰以后，它就可以成为全局静态变量，全局静态变量和其他的全局变量的存储地是一样的，都是在.data段（存放已经初始化了的全局变量）或者.bss段（存放未初始化的全局变量），具体在哪里取决于你有没有初始化这个全局变量。在这里static的作用就是限定作用域了，即被修饰的全局变量只能在定义它的源文件内有效，其他源文件无法访问。 举例如下： .h文件 #include&lt;stdio.h&gt; extern int a;//声明全局变量 void fun();//声明函数 b.c文件 b.c文件 #include&quot;head.h&quot; static int a = 10;//静态全局变量，放在了.data段 void fun() { printf(&quot;%d\\n&quot;, a); } a.c文件 #include&quot;head.h&quot; int main() { printf(&quot;%d&quot;, a); return 0; } 在上述例子中，a.c文件无法使用源文件b.c的被static修饰的全局变量，编译会报错！但是如果在a.c中调用fun函数，在这个函数中使用a就可以，因为其作用域就在其定义的源文件，所以被自己的源文件内的函数访问是没有问题的。 2.修饰局部变量被static修饰的局部变量会被放在.data段，注意这里不是在.bss段，所以这个变量的生命周期在整个程序的生命周期中存在，尽管被放在.data段，但是同样它也只能被自己作用域内的函数或者变量所访问，不能被外界访问。同样static在这里的作用相当于改变了局部变量的生命周期。注意这里解释一下为什么放在了.data段，因为如果用户没有初始化的话，编译器会自动给其赋值0，所以放在了.data段。所以以后每次调用这个变量的时候相当于一直读取同一位置的这个变量，在这里注意和局部变量区别开来。就是因为这一特性，内含静态局部变量的函数是不可重入函数。 b.c文件 #include&quot;head.h&quot; void fun() { static int a; printf(&quot;%d\\n&quot;, a++); } a.c文件 #include&quot;head.h&quot; int main() { fun(); fun(); fun(); getchar(); return 0; } 这样的输出结果是0 1 2. 3.修饰函数这里static的作用也是限定了函数的作用，使被static修饰的函数不能被其他源文件所调用。这里很简单的就不举例子了。static函数可以很好的解决不同源文件中的函数重名的问题，因为每个函数的名字仅自己可见，肯定不会发生冲突的！ 2.C++中的staticC++的中的static关键字主要要讲的就是其修饰的成员变量和成员函数。 1.static修饰成员变量当一个类的成员变量被static关键字修饰以后就变成了静态数据成员了，静态数据成员有一下特点： 1.静态数据成员是类的成员而非对象的成员，它对于所有的对象是共享的，即无论对象被定义了多少个这个静态的成员只有一份，即只分配一次内存，这一样某种程度来说还节省了空间 2.静态成员存储在全局数据区，静态成员在定义的时候要分配空间，所以不不能再类声明的时候定义，需要在类外使用如下形式定义 int myclass::a=0; 3.静态成员同样遵守三个访问限制，同时即使不定义类对象也可以对它进行操作 4.静态成员的作用就是在多个对象拥有同一个属性的时候，使用它可以方便操作，改变一次就全部改变，使用静态数据成员也不存在和其他全局变量的名字冲突，因为其有访问限制属性所以可以实现信息隐藏。 2.static修饰成员函数1.同样静态成员函数也是被所有对象共享，并且他没有this指针，所以他不能访问成员函数和成员变量只能访问静态成员函数和静态成员变量，但是非静态成员函数可以访问静态成员函数和静态变量 2.因为没有this指针，其速度相对于成员函数来说会快一些 3.调用静态成员函数的方式和调用静音胎成员的方式差不多，可以使用.，-&gt;和::","categories":[{"name":"c/c++","slug":"c-c","permalink":"http://yoursite.com/categories/c-c/"}],"tags":[{"name":"static","slug":"static","permalink":"http://yoursite.com/tags/static/"}]},{"title":"堆随笔","slug":"堆随笔","date":"2018-02-24T13:59:15.000Z","updated":"2018-02-24T15:00:39.218Z","comments":true,"path":"2018/02/24/堆随笔/","link":"","permalink":"http://yoursite.com/2018/02/24/堆随笔/","excerpt":"这篇博客的主要内容是对于堆的一些总结","text":"这篇博客的主要内容是对于堆的一些总结 1.创建堆首先堆这个对象的框架你要能够很清楚的记得，即私有成员是vecotr的容器比较好，还有一个就是size用来记录堆中的元素，这样可以用来盛放外界数组的元素，其构造函数主要的作用就是将外界数组元素保存到自己的容器中，然后如果你想创建小堆则用向下调整法，这样堆最开始的创建的就结束了。 2.向下调整法此方法用于建立小堆的时候可以使用，首先数组是根据完全二叉树的方式在数组中存储的，所以我们可以借助树的模型来简化我们的操作，首先需要找到倒数第一个叶子结点的父结点从这里开始调整,这个父结点的位置怎么找呢？举个例子找到父结点的位置以后开始进行调整，首先需要根据父结点在找出其孩子结点的位置，这个很好找就是父结点的位置*2+1就是孩子结点的位置，因为是向下调整发，所以需要判断左右孩子哪个大，找出最小的那个孩子，然后让他和父结点去比较，然后继续向下走继续比较，依此类推。再次我给出代码 // void _Adjustdown(size_t parent) // { // size_t child = parent * 2 + 1;//保存左孩子 // while (child &lt; _size)//在这里的条件给成child&lt;size比较好 // { // Compare s;//定义仿函数对象 // //if (child + 1&lt;_size&amp;&amp;_array[child] &gt;_array[child + 1])//找最小的孩子 // // ++child; // if (child + 1 &lt; _size&amp;&amp;s(_array[child], _array[child + 1]))//找最小的孩子 // ++child; // if (/*child&lt;_size*/s(_array[parent], _array[child])) // { // swap(_array[parent], _array[child]); // parent = child; // child = parent * 2 + 1; // } // else//已经交换好了 // { // break; // } // } // } 在上述代码我想想强调的只有两点： 1.在判断左右孩子的时候当心父结点是单支结点，所以要判断chil+1&lt;size 2.在判断父结点和孩子结点谁小的时候，要当心孩子就结点超出size的大小，需要判断child=0;i–);来循环调整 3.堆的插入操作堆的插入使用的是向上调整法，因为插入之前堆已经建立好了则意味着调整好了，所以插入一个新结点以后意味着，插入的那棵和那棵树的祖先可能会不满足堆的性质，所以只需要顺着那一个方向一直向上调整就可以了，和向下调整法的差别不大，不过这个没有for循环，因为不需要挨个调整呀。给出代码： // void _Adjustup(int child)//向上调整 // { // int parent =(child-1)&gt;&gt;1; // while (parent&gt;=0) // { // if (Compare()(_array[parent], _array[child]))//使用简单的比较器 // { // swap(_array[parent], _array[child]); // child = parent; // parent = (child - 1) &gt;&gt; 1; // } // else // break; // } // } // //}; 在这个算法中我要强调的就是： 1.首先要根据孩子结点找到父结点2.循环的条件是parent&gt;=0 3.堆的pop堆的pop使用的算法有点乾坤大挪移的感觉，将堆顶元素和最后一个元素互换，然后使size–，然后使用向下调整法就解决了，是不是很奇妙 // void Heap_del()//删除堆顶的元素 // { // if (_array.empty()) // return;//空的话直接返回 // int size_last = _size - 1; // swap(_array[0], _array[size_last]); // _array.pop_back();//弹出去 // _size--; // if (_size &gt; 0) // { // _Adjustdown(0); // } // } 重点：1.从头开始调整，但是不需要循环调整！这里就牵扯到了你的向下调整的for循环是写在哪里了。 4.堆排序堆排序的思路也很简单主要是利用堆的性质，如果你要升序排序的话建立大堆，你要降序排序的话建立小堆，然后和删除的思路基本一致，首尾互换然后size– // void Head_Sort() // { // while (_size &gt; 1) // { // swap(_array[0], _array[_size - 1]); // //这里和删除的区别只是不弹出 // --_size; // _Adjustdown(0); // } // } 注意：这里和删除的区别就是不用弹出元素.还有就是break可以直接换成return; 5.优先级队列如何用堆来建立优先级队列呢？首选封装优先级队列的对象里面的成员就是堆，然后只需要使用堆的插入和删除就可以实现优先级队列了。 关于堆的优化就是加入仿函数。","categories":[{"name":"数据结构随笔","slug":"数据结构随笔","permalink":"http://yoursite.com/categories/数据结构随笔/"}],"tags":[{"name":"heap","slug":"heap","permalink":"http://yoursite.com/tags/heap/"}]},{"title":"sizeof详解","slug":"sizeof详解","date":"2018-02-24T07:42:50.000Z","updated":"2018-02-24T13:14:35.584Z","comments":true,"path":"2018/02/24/sizeof详解/","link":"","permalink":"http://yoursite.com/2018/02/24/sizeof详解/","excerpt":"首先对于sizeof做一个简单的介绍让你知道什么是sizoef，从心里对它有个大致的印象。","text":"首先对于sizeof做一个简单的介绍让你知道什么是sizoef，从心里对它有个大致的印象。 定义： sizeof是C/C++中的一个操作符（operator），简单的说其作用就是返回一个对象或者类型所占的内存字节数。 MSDN上的解释为：The sizeof keyword gives the amount of storage, in bytes, associated with a variable or a type(including aggregate types). This keyword returns a value of type size_t. 其返回值类型为size_t，在头文件stddef.h中定义。这是一个依赖于编译系统的值，一般定义为 typedef unsigned int size_t; 好了现在你应该对于sizoef有了一个大概的认识了，现在我们来看看sizoef的基本用法： sizeof(对象）； sizeof(类型）； sizeof 对象；//这个主意和1区分 对于上面的三种用法，其实你只需要掌握sizoef()的这种用法就够了，另外一个自己知道就可以了，因为根本没人去那么用。好了划重点了：记住sizeof计算对象的大小也是转换成对应的类型来计算的，这句话的言外之意就是不同的对象如果类型一样的话，sizoef计算的值是一样的。 用法： 接下来我就所说sizeof的一些应用场景和用法 1 sizeof对一个表达式求值注意：对于表达式求值，编译器会根据表达式结果的类型来计算，一般不会对表达式进行计算 举例如下： int fun(int a) { cout &lt;&lt; &quot;fun::sizoef&quot; &lt;&lt; endl; return a; } void test() { cout &lt;&lt; sizeof(fun(4)); } 此例子的输出就是 4，不会输出fun::sizeof,证明函数没有执行。 2.sizoef的常量性sizeof的计算是放生在编译期间的，所以其可以被当做常量表达式使用 举例如下： int n=10; int arr[sizeof(n)]; 3.sizeof和指针变量注意：当sizoef的对象是指针变量的时候，它的结果和指针所指的内容没有任何的关系，所以在32位计算机中指针变量是4,64位计算机中是8 4.sizeof和数组sizoef的数组的值等于数组所占的内存字节数，这里我在CSDN的博客写的很清楚了，感兴趣的可以自己去看http://blog.csdn.net/it_iverson/article/details/74733426 这里还要强调的一个重点就是数组传参的时候。 void fun(int arr[]) { cout &lt;&lt; sizeof(arr); } void test() { int arr[10] = { 0 }; fun(arr); } 这里的sizoef的输出是4而不是40，因为在函数的形参那里arr已经不是数组类型了，而是蜕变成了指针。相当于int *arr,因为数组是传址传参的，只是把数组首地址传过去了，所以接受地址的自然就是指针变量了，那么正如上文所说，指针变量的大小和其指向的内容没有关系，所以大小为4 5.sizeof和结构体这里主要强调的是结构体内存对其的一些知识在CSDN的博客中也有详细说明 http://blog.csdn.net/it_iverson/article/details/74790127 6.含有位字段的结构体 注意：单独的位字段成员不能被sizeof求值 那么什么是为字段呢？ 位字段是C语言中一种存储结构，不同于一般结构体的是它在定义成员的时候需要指定成员所占的位数。主要应用于嵌入开发 如下： struct stu { char a : 4;//占4位 char b : 3;//占3位 char c : 8;//占8位 };//大小为两个字节 在这里要注意的是： 1.如果相邻的位字段的类型相同，且其位数之和小于自身类型数，则后面的字段和紧挨着前面的字段存储，直到这个不能容纳为止 2.如果相邻的位字段类型相同，且其位数之和大于自身的类型数，则后面的字段从新的存储单元开始。 3.如果相邻位字段类型不同，则根据编译器的不同，是否采取压缩存储就不一定了。 4.如果位字段之间穿插着非为字段，则不进行压缩存储 7.sizeof和联合体因为联合体是重叠式存储，各成员共享一段内存，所以整个联合体的大小就是最大成员所占的空间的大小，假如联合体中有一个结构体成员，那么这个联合体的大小就是这个结构体的大小。","categories":[{"name":"c/c++","slug":"c-c","permalink":"http://yoursite.com/categories/c-c/"}],"tags":[{"name":"sizeof","slug":"sizeof","permalink":"http://yoursite.com/tags/sizeof/"}]}]}